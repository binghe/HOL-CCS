\section{Formalisation}

We highlight here a formalisation of CCS
in the HOL theorem
prover (HOL4) \cite{slind2008brief},
including the new concepts and theorems proposed in the first half of
this paper.
%  The main purpose is to convince the readers that, there's no flaw
%  in the informal proofs. 
The whole formalisation can be found 
in \cite{Tian:2017wrba}  or in 
 in the official example folder of HOL4 source
code\footnote{\url{https://github.com/HOL-Theorem-Prover/HOL}}. The
work consists of about 20,000 lines of proof scripts in Standard ML,
derived from an early work \cite{Nesi:1992ve} by Monica Nesi in 1992-1995.

HOL4 is written in Standard ML (or ML for abbreviation). This single language plays three roles here:
\begin{enumerate}
\item It serves as the underlying implementation language for the core HOL engine;
\item It's used to implement tactics (and tacticals) for automatic theorem proving;
\item It's used as the command language of the interactive HOL system.
\end{enumerate}
Besides, HOL4 users can write arbitrary applications which leverages
the theorem proving facility. 

Higher Order Logic (or ``HOL Logic'') \cite{hollogic} stands for simple-typed $\lambda$-calculus plus Hibert
choice operator, axiom of infinity, and rank-1 polymorphim (type
variables). HOL4 implemented the original HOL Logic, while
some other theorem provers of the HOL family (e.g. Isabelle/HOL) added
further extensions (they made the formal language more powerful,
but they also bring the possibilities that the entire logic becomes inconsistent).
The HOL Logic has considerability simpler logic
foundations than most other theorem provers, e.g. Coq. As a result,
formal theories in HOL can be easily migrated (sometimes even
automatically) into other theorem provers.

\finish{below: to be reformulated (by Davide) later} 
We will not repeat all definitions and theorems of CCS again by their
formalized versions. Instead, we just focus on several highlights in
this work, i.e.
\begin{enumerate}
\item The use of HOL's new coinductive relation package for defining bisimilarity;
\item The formalisation of context by $\lambda$-expression and the theory of
  (pre)congruence for CCS;
\item The definition and uses of trace in the proof of unique solution of
  contractions theorem;
\end{enumerate}\finish{TODO: need updates}

In contrast with the theorems in the first part of the paper, in the
formalisation we consider only single equations/contractions. 
This considerably simplifies the  reading of the HOL scripts. 
The extension of the work to multiple equations/contractions is
discussed in Section~\ref{s:concl}.

% \subsection{Simplifications and Limitations}

% We have only formally verified simplified forms of the unique
% solution theorems introduced in the first part. This is to not only
% save the formalisation efforts, but also to make us focusing on the most
% important part of the proof. The most important simplification is
% that, we have only proved all unique solution theorems with only single-variable equations
% (contractions).

% But such a simplification doesn't hurt the rigorousness of our entire
% work, as once the single-equation version of the theorem is
% proven, the general case is just a routine
% adaptation for paper proofs.
% It's not easy to formalize multi-variable CCS equations with
% introducing a large number of definitions and intermediate
% results. It's easy, however, to directly use the semantics context to
% represent single-variable equations without the need of formalizing
% the concept of ``equation'' at all.

% There're two major limitations in this work. One is due to HOL, we only support Finitary CCS, i.e.
% no infinite sum nor infinite parallel composition.
% The other limitation is, equation variables (or holes in semantics contexts)
% cannot appear inside recursion operator closure. However, these limitations do not
% cause any difference in the proof of main results represented in this paper.
