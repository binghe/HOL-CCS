%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{CCS and its transitions by SOS rules}

In our CCS formalisation, the type ``\HOLty{:'b Label}'' ($\beta$ is a
type variable) accounts for visible actions, divided into input
and output actions, defined by HOL's Datatype package: (\texttt{'b} or
$\beta$ is the type variable for actions)
\begin{lstlisting}
val _ = Datatype `Label = name 'b | coname 'b`;
\end{lstlisting}
The type ``\HOLty{:'b Action}'' is the
union of all visible and invisible actions. The cardinality of
``\HOLty{:'b Action}'' (and therefore of all
CCS types built on top of it)
 depends on the choice (or \emph{type-instantiation}) of $\beta$.

The core datatype ``\HOLty{:('a, 'b) CCS}'', accounting for the CCS
syntax\footnote{\hl{The order of type variables $\alpha, \beta$ can be
    arbitrary. But our choice is aligned with other CCS literals.
$\mathrm{CCS}(h,k)$ is the CCS subcalculus which can use at most $h$ constants
and $k$ actions.} \cite{gorrieri2017ccs} \hl{Thus, to formalize theorems on
this kind of CCS subcalculus, it is enough to instantiate the type
variables $\alpha, \beta$ with types having the corresponding cardinalities $h, k$.}}, is then defined inductively:
(\texttt{'a} or $\alpha$ is the type variable for recursion variables,
``\HOLty{:'b Relabeling}'' is \hl{the type of all relabeling functions,
`\mbox{\color{red}{\texttt{`}}}' is the backquote for HOL terms}):
\begin{lstlisting}
val _ = Datatype `CCS = nil
		      | var 'a
		      | prefix ('b Action) CCS
		      | sum CCS CCS
		      | par CCS CCS
		      | restr (('b Label) set) CCS
		      | relab CCS ('b Relabeling)
		      | rec 'a CCS`;
\end{lstlisting}

We have added some grammar support,
 using \hl{HOL's powerful pretty printer}, to represent CCS
processes in more readable forms (c.f. the column \textbf{HOL (abbrev.)}
in Table \ref{tab:ccsoperator}, \hl{which} summarizes 
the main syntactic notations \hl{of} CCS). For the restriction
operator, we have chosen to allow a  set of names as a parameter, rather than a
  single name as in the ordinary  CCS syntax; this simplifies 
the manipulation of 
 processes with different orders of
  nested restrictions.
% Also, we do not assume that the uses of \texttt{var} are
%  guarded by \texttt{rec} of the same variable.

%  (Notice the use of
% recursion operator for representing process constants)
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Operator} & \textbf{CCS Notation} & \textbf{HOL term} &
                                                                \textbf{HOL (abbrev.)}\\
\hline
nil & $\textbf{0}$ & \HOLtm{nil} & \HOLtm{nil} \\
prefix & $u.P$ & \texttt{prefix u P} & \HOLtm{prefix u P} \\
sum & $P + Q$ & \texttt{sum P Q} & \HOLtm{sum P Q} \\
parallel & $P \,\mid\, Q$ & \texttt{par P Q} & \HOLtm{P || Q} \\
restriction & $(\nu\;L)\;P$ & \texttt{restr L P} & \HOLtm{restr L P}
  \\
recursion & $\recu A P$ & \texttt{rec A P} & \HOLtm{rec A P}
  \\
relabeling & $P\;[r\!\!f]$ & \texttt{relab P rf} & \HOLtm{relab P rf}
  \\
\hline
invisible action & $\tau$ & \texttt{tau} & \HOLtm{tau} \\
input action & $a$ & \texttt{label (name a)} & \HOLtm{label (name a)} \\
output action & $\outC a$ & \texttt{label (coname a)} & \HOLtm{label (coname a)} \\
\hline
\end{tabular}
\end{center}
\vspace{-1em}
   \caption{Syntax of CCS operators}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes  follows
the Structural Operational Semantics (SOS) rules in
Figure~\ref{f:LTSCCS}:
\begin{alltt}
\HOLthm{Example.PREFIX'}\hfill\texttt{[PREFIX]}
\HOLthm{Example.SUM1'}\hfill\texttt{[SUM1]}
\HOLthm{Example.SUM2'}\hfill\texttt{[SUM2]}
\HOLthm{Example.PAR1'}\hfill\texttt{[PAR1]}
\HOLthm{Example.PAR2'}\hfill\texttt{[PAR2]}
\HOLthm{Example.PAR3'}\hfill\texttt{[PAR3]}
\HOLthm{Example.RESTR'}\hfill\texttt{[RESTR]}
\HOLthm{Example.RELABELING'}\hfill\texttt{[RELABELING]}
\HOLthm{Example.REC'}\hfill\texttt{[REC]}
\end{alltt}

The rule \texttt{[REC]} (Recursion)
 says that if we substitute all appearances of variable $A$ in $P$ to
$(\mathbf{rec}\; A\; P)$ and the resulting process has a transition to $P'$
with action $u$, then $(\mathbf{rec}\; A\; P)$ has the same
transition. From the HOL  viewpoint, these
SOS rules are \emph{inductive 
  definitions} on the 3-ary relation \HOLtm{TRANS} of type ``\HOLty{:('a, 'b) CCS ->
  'b Action -> ('a, 'b) CCS -> bool}'', generated by HOL's 
\texttt{Hol_reln} function (inductive relation package).

A useful function that we have defined, exploiting the interplay
between HOL4 and Standard ML (and following an idea by Nesi \cite{Nesi:1992ve})
 is a complex Standard ML function
  taking a CCS process and returning a theorem indicating all its
  direct transitions.\footnote{If the input process could yield
    something infinite branching, due to the use of recursion or
    relabeling operators, the program will loop forever without
    outputing a theorem.}
For instance, we know that the process $(a.0 | \bar{a}.0)$ has three
possible transitions: $(a.0 | \bar{a}.0) \overset{a}{\longrightarrow}
(0 | \bar{a}.0)$, $(a.0 | \bar{a}.0)
\overset{\bar{a}}{\longrightarrow} (a.0 | 0)$ and $(a.0 | \bar{a}.0)
\overset{\tau}{\longrightarrow} (0 | 0)$.
To completely describe all possible transitions of a process, if done manually, the
following facts should be proved:
\begin{enumerate}
\iflong
\item there exists transitions from $(a.0 | \bar{a}.0)$ (optional);
\fi
\item the correctness for each of the transitions;
\item the non-existence of other transitions.
\end{enumerate}
For large processes it may be surprisingly hard to manually prove the
non-existence of transitions.  Hence the usefulness of appealing to 
the new  function \texttt{CCS\_TRANS\_CONV}. 
For instance this function
is called on the  process $(a.0 | \bar{a}.0)$ thus:
\hl{(`\mbox{\color{red}{\texttt{``}}}' is the double-backquote for HOL terms)}
\begin{lstlisting}
> CCS_TRANS_CONV ``par (prefix (label (name "a")) nil)
                       (prefix (label (coname "a")) nil)``
\end{lstlisting}
This returns the following theorem, indeed describing all immediate
transitions of the process:
\begin{alltt}
\HOLthm{Example.ex_A}
\end{alltt}
