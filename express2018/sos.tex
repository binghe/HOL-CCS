%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{CCS and transitions based on SOS rules}

In the formalization of CCS, 
the type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Label}}'' ($\beta$ is a
type variable) accounts for visible actions, divided into input
and output actions:
\begin{lstlisting}
val _ = Datatype `Label = name 'b | coname 'b`;
\end{lstlisting}
Then
the type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}}'' is the
union of all visible and invisible actions. The cardinality of
``\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}}'' (and therefore of all
CCS types built on top of it) 
 depends on the choice of initial  type $\beta$.

The core datatype ``\HOLinline{(\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS}}'', accounting for the CCS syntax, is then defined as an inductive
datatype in HOL, based on its Datatype package: ($\alpha$ is the type
variable for recursion variables) 
\begin{lstlisting}
val _ = Datatype `CCS = nil
		      | var 'a
		      | prefix ('b Action) CCS
		      | sum CCS CCS
		      | par CCS CCS
		      | restr (('b Label) set) CCS
		      | relab CCS ('b Relabeling)
		      | rec 'a CCS`;
\end{lstlisting}

We have added some  grammar support using HOL's powerful pretty printer, to represent CCS
processes in more readable forms (as shown in the ``HOL (abbrev.)''
column in Table \ref{tab:ccsoperator}, the rest of table has listed the notation of typical CCS processes and
major operators supported by above definition). For restriction
operator, we chose to takes a set of names, rather than a
  single name as in the  CCS syntax, to prevent the formalization
  efforts on the equivalence of CCS processes with different order of
  nested restrictions. Also, we don't assume that al recursion are
  guarded, i.e. any term like \texttt{var X} must appear in \texttt{P} of \texttt{rec X P}.

%  (Notice the use of
% recursition operator for representing process constants)
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Operator} & \textbf{CCS Notation} & \textbf{HOL term} &
                                                                \textbf{HOL (abbrev.)}\\
\hline
nil & $\textbf{0}$ & \HOLinline{\HOLConst{nil}} & \HOLinline{\HOLConst{nil}} \\
prefix & $u.P$ & \texttt{prefix u P} & \HOLinline{\HOLFreeVar{u}\HOLSymConst{..}\HOLFreeVar{P}} \\
sum & $P + Q$ & \texttt{sum P Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{+} \HOLFreeVar{Q}} \\
parallel & $P \,\mid\, Q$ & \texttt{par P Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{Q}} \\
restriction & $(\nu\;L)\;P$ & \texttt{restr L P} & \HOLinline{\HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{P}}
  \\
recursion & $A$ with $A\Defi P$ & \texttt{rec A P} & \HOLinline{\HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{P}} \\
input action & $a$ & \texttt{label (name a)} & \HOLinline{\HOLConst{In} \HOLFreeVar{a}} \\
output action & $\outC a$ & \texttt{label (coname a)} & \HOLinline{\HOLConst{Out} \HOLFreeVar{a}} \\
\hline
\end{tabular}
\end{center}
\vspace{-1em}
   \caption{Syntax of CCS operators}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes  follows
the Structural Operational Semantics (SOS) rules in
Figure~\ref{f:LTSCCS}:
\begin{alltt}
\HOLTokenTurnstile{} \HOLFreeVar{u}\HOLSymConst{..}\HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E}\hfill\texttt{[PREFIX]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E} \HOLSymConst{+} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[SUM1]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E\sp{\prime}} \HOLSymConst{+} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[SUM2]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sp{\prime}}\hfill\texttt{[PAR1]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[PAR2]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLConst{label} \HOLFreeVar{l}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLConst{label} (\HOLConst{COMPL} \HOLFreeVar{l})\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{2}}} \HOLSymConst{\HOLTokenImp{}}
   \HOLFreeVar{E} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLSymConst{\ensuremath{\tau}}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sb{\mathrm{2}}}\hfill\texttt{[PAR3]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\HOLTokenConj{}} ((\HOLFreeVar{u} \HOLSymConst{=} \HOLSymConst{\ensuremath{\tau}}) \HOLSymConst{\HOLTokenDisj{}} (\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{label} \HOLFreeVar{l}) \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L} \HOLSymConst{\HOLTokenConj{}} \HOLConst{COMPL} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L}) \HOLSymConst{\HOLTokenImp{}}
   \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{E\sp{\prime}}\hfill\texttt{[RESTR]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLConst{relab} \HOLFreeVar{E} \HOLFreeVar{rf} \HOLTokenTransBegin\HOLConst{relabel} \HOLFreeVar{rf} \HOLFreeVar{u}\HOLTokenTransEnd \HOLConst{relab} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{rf}\hfill\texttt{[RELABELING]}
\HOLTokenTurnstile{} \HOLConst{CCS_Subst} \HOLFreeVar{E} (\HOLConst{rec} \HOLFreeVar{X} \HOLFreeVar{E}) \HOLFreeVar{X} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLConst{rec} \HOLFreeVar{X} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[REC]}
\end{alltt}

Here the rule \texttt{[REC]} (Recursion)
 says that if we substitute all appearences of variable $A$ in $E$ to
$(\mathbf{rec}\; A\; E)$ and the resulting process has a transition to $E_1$
with action $u$, then $(\mathbf{rec}\; A\; E)$ has the same
transition. From the HOL  viewpoint, these
SOS rules are \emph{inductive 
  definitions} on the 3-ary relation \HOLinline{\HOLConst{TRANS}} of type ``\HOLinline{(\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS} \HOLTokenTransEnd \ensuremath{\beta} \HOLTyOp{Action} \HOLTokenTransEnd (\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS} \HOLTokenTransEnd \HOLTyOp{bool}}'', generated by HOL4's 
\texttt{Hol_reln} function.\footnote{\texttt{Hol_reln} also
gives us a fix-point theorem and induction principle for the
relation, otherwise statements like ``$\textbf{0}$ has no transition''
could not be proved.}

HOL4 is written in Standard ML (or ML for abbreviation). This single language plays three roles here:
\begin{enumerate}
\item It serves as the underlying implementation language for the core HOL engine;
\item It's used to implement tactics (and tacticals) for automatic theorem proving;
\item It's used as the command language of the interactive HOL system.
\end{enumerate}
Besides, HOL4 users can write arbitrary applications which leverages
the theorem proving facility. The ultimate result (initially done by Nesi)
at this point, is a complex Standard ML function
  taking a CCS process and returning a theorem indicating all its direct transitions.

For instance, we know that the process $(a.0 | \bar{a}.0)$ have three
possible transitions: $(a.0 | \bar{a}.0) \overset{a}{\longrightarrow}
(0 | \bar{a}.0)$, $(a.0 | \bar{a}.0)
\overset{\bar{a}}{\longrightarrow} (a.0 | 0)$ and $(a.0 | \bar{a}.0)
\overset{\tau}{\longrightarrow} (0 | 0)$.
To completely decide all possible transitions, if done manually, the
following facts should be proved:
\begin{enumerate}
\item there exists transitions from $(a.0 | \bar{a}.0)$ (optional);
\item the correctness for each of the transitions by SOS rules;
\item there's no other transition beside the three existing ones.
\end{enumerate}
For large complex processes it's surprisingly hard to manually prove the
non-existence of transitions. Instead, if we call the ML function \texttt{CCS\_TRANS\_CONV} on the
root process $(a.0 | \bar{a}.0)$:
\begin{lstlisting}
> CCS_TRANS_CONV
	 ``par (prefix (label (name "a")) nil)
	       (prefix (label (coname "a")) nil)``
\end{lstlisting}
We immediately get the following theorem, which completely answers the question:
\begin{alltt}
\HOLTokenTurnstile{} \HOLConst{In} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{Out} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E} \HOLSymConst{\HOLTokenEquiv{}}
   ((\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{In} \HOLStringLit{a}) \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{E} \HOLSymConst{=} \HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{Out} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil}) \HOLSymConst{\HOLTokenDisj{}}
    (\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{Out} \HOLStringLit{a}) \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{E} \HOLSymConst{=} \HOLConst{In} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{nil})) \HOLSymConst{\HOLTokenDisj{}}
   (\HOLFreeVar{u} \HOLSymConst{=} \HOLSymConst{\ensuremath{\tau}}) \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{E} \HOLSymConst{=} \HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{nil})
\end{alltt}
