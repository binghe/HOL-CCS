%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{CCS and transitions based on SOS rules}

In the formalization of CCS, 
the type \HOLinline{\ensuremath{\beta} \HOLTyOp{Label}} ($\beta$ is a
type variable) accounts for visible actions, divided into input
and output actions:
\begin{lstlisting}
val _ = Datatype `Label = name 'b | coname 'b`;
\end{lstlisting}
Then
the type \HOLinline{\ensuremath{\beta} \HOLTyOp{Action}} is the
union of all visible and invisible actions. The cardinality of
\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}} (and therefore of all
CCS types built on top of it) 
 depends on the choice of initial  type $\beta$.
\finish{i have reformulated the sentence above; check it} 



The core datatype ``\HOLinline{(\ensuremath{\alpha},
  \ensuremath{\beta}) \HOLTyOp{CCS}}'', accounting for the CCS syntax,  is then defined as an inductive
datatype in HOL, based on its Datatype package:
\finish{above: check the change i made. Also, explain what is $\alpha
  $ (i suppose the set of  variables for recursion)} 
\begin{lstlisting}
val _ = Datatype `CCS = nil
		      | var 'a
		      | prefix ('b Action) CCS
		      | sum CCS CCS
		      | par CCS CCS
		      | restr (('b Label) set) CCS
		      | relab CCS ('b Relabeling)
		      | rec 'a CCS`;
\end{lstlisting}

We have added some  grammar support using HOL's powerful pretty printer, to represent CCS
processes in more readable forms. Table \ref{tab:ccsoperator} has listed the notation of typical CCS processes and
major operators supported by above definition.

\finish{explain what is ``HOL   (alternative)''. 
Also: the table gives the impression that all recursion are guarded,
ie, the body of the recursion begins with a prefix. I would instead
put in the table the plain recursion rec A.P. Also, in the row for
prefix, i would write plain prefix u.P}
\finish{explain why restriction takes a set of names, rather than a
  single name as in the  CCS syntax} 

%  (Notice the use of
% recursition operator for representing process constants)
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Operator} & \textbf{CCS Notation} & \textbf{HOL term} & \textbf{HOL
  (alternative)}\\
\hline
nil & $\textbf{0}$ &  \HOLinline{\HOLConst{nil}} & \HOLinline{\HOLConst{nil}} \\
Prefix & $a.b.0$ & \texttt{prefix a (prefix b nil)} & \HOLinline{\HOLFreeVar{a}\HOLSymConst{..}\HOLFreeVar{b}\HOLSymConst{..}\HOLConst{nil}} \\
Sum & $p + q$ & \texttt{sum p q} & \HOLinline{\HOLFreeVar{p} \HOLSymConst{+} \HOLFreeVar{q}} \\
Parallel & $p \,\mid\, q$ & \texttt{par p q} & \HOLinline{\HOLFreeVar{p} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{q}} \\
Restriction & $(\nu\;L)\;p$ & \texttt{restr L p} & \HOLinline{\HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{p}} \\
Recursion & $A=a.A$ & \texttt{rec A (prefix a (var A))} & \HOLinline{\HOLConst{rec} \HOLFreeVar{A} (\HOLFreeVar{a}\HOLSymConst{..}\HOLConst{var} \HOLFreeVar{A})} \\
\hline
\end{tabular}
\end{center}
\vspace{-1em}
   \caption{Syntax of CCS operators}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes  follows
the Structural Operational Semantics (SOS) rules in
Figure~\ref{f:LTSCCS}:
\begin{alltt}
\HOLTokenTurnstile{} \HOLFreeVar{u}\HOLSymConst{..}\HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E}\hfill\texttt{[PREFIX]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E} \HOLSymConst{+} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[SUM1]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E\sp{\prime}} \HOLSymConst{+} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[SUM2]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sp{\prime}}\hfill\texttt{[PAR1]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[PAR2]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLConst{label} \HOLFreeVar{l}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLConst{label} (\HOLConst{COMPL} \HOLFreeVar{l})\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{2}}} \HOLSymConst{\HOLTokenImp{}}
   \HOLFreeVar{E} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLSymConst{\ensuremath{\tau}}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sb{\mathrm{2}}}\hfill\texttt{[PAR3]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\HOLTokenConj{}} ((\HOLFreeVar{u} \HOLSymConst{=} \HOLSymConst{\ensuremath{\tau}}) \HOLSymConst{\HOLTokenDisj{}} (\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{label} \HOLFreeVar{l}) \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L} \HOLSymConst{\HOLTokenConj{}} \HOLConst{COMPL} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L}) \HOLSymConst{\HOLTokenImp{}}
   \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{E\sp{\prime}}\hfill\texttt{[RESTR]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLConst{relab} \HOLFreeVar{E} \HOLFreeVar{rf} \HOLTokenTransBegin\HOLConst{relabel} \HOLFreeVar{rf} \HOLFreeVar{u}\HOLTokenTransEnd \HOLConst{relab} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{rf}\hfill\texttt{[RELABELING]}
\HOLTokenTurnstile{} \HOLConst{CCS_Subst} \HOLFreeVar{E} (\HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{E}) \HOLFreeVar{A} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}
\texttt{[RECURSION]}
\end{alltt}
The rule 
\texttt{[RECURSION]
 says that if we substitute all appearences of variable $A$ in $E$ to
$(\mathbf{rec}\; A\; E)$ and the resulting process has a transition to $E_1$
with action $u$, then $(\mathbf{rec}\; A\; E)$ has the same
transition. 


% Above rules work as \emph{axioms} in the theory of CCS, as they cannot be
% proved by more primitive theorems or axioms. 

From the HOL  viewpoint, these
SOS rules are \emph{inductive 
  definitions} on the 3-ary relation \HOLinline{\HOLConst{TRANS}} of type ``\HOLinline{(\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS} \HOLTokenTransEnd \ensuremath{\beta} \HOLTyOp{Action} \HOLTokenTransEnd (\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS} \HOLTokenTransEnd \HOLTyOp{bool}}'', generated by HOL4's function
\texttt{Hol_reln}.\footnote{\texttt{Hol_reln} also
gives us a fix-point theorem and induction principle for the
relation, otherwise statements like ``$\textbf{0}$ has no transition''
could not be proved.} 


\finish{the text below is important but there are various things that
  are not clear: where does ML come from (we have not talked about ML
  before and for a non-expert in HOL this is a mystery)? did you have
  to define it? was it difficult or is there some HOL facility that helps? } 

The ultimate result here (before
bisimilution gets involved), is an ML function
\finish{is this the function \texttt{CCS\_TRANS\_CONV}}  mentioned
later below? }
  taking a CCS process
and returning a theorem indicating all its direct transitions.

For instance, we know that the process $(a.0 | \bar{a}.0)$ have three
possible transitions:
\begin{enumerate}
\item $(a.0 | \bar{a}.0) \overset{a}{\longrightarrow} (0 | \bar{a}.0)$;
\item $(a.0 | \bar{a}.0) \overset{\bar{a}}{\longrightarrow} (a.0 | 0)$;
\item $(a.0 | \bar{a}.0) \overset{\tau}{\longrightarrow} (0 | 0)$.
\end{enumerate}
To completely decide all possible transitions, if done manually, the
following results must be proved:
\begin{enumerate}
\item there exists transitions from $(a.0 | \bar{a}.0)$ (optionally);
\item each of above three transitions using SOS inference rules;
\item there's no other transition beside the three existing ones.
\end{enumerate}
For large complex processes it's surprising hard to prove the
non-existence of transitions. Instead, if we call the function \texttt{CCS\_TRANS\_CONV} with the
root process:
\begin{lstlisting}
> CCS_TRANS_CONV
	 ``par (prefix (label (name "a")) nil)
	       (prefix (label (coname "a")) nil)``
\end{lstlisting}
we get the following theorem, which completely answers the question:
\begin{alltt}
\HOLTokenTurnstile{} \HOLConst{In} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{Out} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E} \HOLSymConst{\HOLTokenEquiv{}}
   ((\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{In} \HOLStringLit{a}) \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{E} \HOLSymConst{=} \HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{Out} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil}) \HOLSymConst{\HOLTokenDisj{}}
    (\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{Out} \HOLStringLit{a}) \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{E} \HOLSymConst{=} \HOLConst{In} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{nil})) \HOLSymConst{\HOLTokenDisj{}}
   (\HOLFreeVar{u} \HOLSymConst{=} \HOLSymConst{\ensuremath{\tau}}) \HOLSymConst{\HOLTokenConj{}} (\HOLFreeVar{E} \HOLSymConst{=} \HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{nil})
\end{alltt}
