%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{CCS processes and their transitions}

In our CCS formalisation, the type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Label}}'' (\texttt{'b} or
$\beta$ is the type variable for actions) accounts for visible actions, divided into input
and output actions, defined by HOL's Datatype package:
\begin{lstlisting}
val _ = Datatype `Label = name 'b | coname 'b`;
\end{lstlisting}
The type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}}'' is the
union of all visible actions, plus invisible action $\tau$ (now based on
HOL's \texttt{option} theory). The cardinality of
``\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}}'' (and therefore of all
CCS types built on top of it)
 depends on the choice (or \emph{type-instantiation}) of \hl{type variable} $\beta$.

The type ``\HOLinline{(\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS}}'', accounting for the CCS
syntax\footnote{The order of type variables $\alpha$ and $\beta$
    is arbitrary. Our choice is aligned with other CCS literals.
$\mathrm{CCS}(h,k)$ is the CCS subcalculus which can use at most $h$ constants
and $k$ actions. \cite{gorrieri2017ccs} Thus, to formalize theorems on
such a CCS subcalculus, the needed CCS type can be retrieved by instantiating the type
variables $\alpha$ and $\beta$ in ``\HOLinline{(\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS}}'' with types
having the corresponding cardinalities $h$ and $k$. Monica Nesi goes
too far by adding another type variable $\gamma$ for value-passing CCS
\cite{Nesi:2017wo}.}, is then defined inductively:
(\texttt{'a} or $\alpha$ is the type variable for recursion variables,
``\HOLinline{\ensuremath{\beta} \HOLTyOp{Relabeling}}'' is the type of all relabeling functions,
\mbox{\color{blue}{\texttt{`}}} is for backquotes of HOL terms):
\begin{lstlisting}
val _ = Datatype `CCS = nil
		      | var 'a
		      | prefix ('b Action) CCS
		      | sum CCS CCS
		      | par CCS CCS
		      | restr (('b Label) set) CCS
		      | relab CCS ('b Relabeling)
		      | rec 'a CCS`;
\end{lstlisting}

We have added some grammar support,
 using HOL's powerful pretty printer, to represent CCS
processes in more readable forms (c.f. the column ``HOL (abbrev.)''
of Table \ref{tab:ccsoperator}, which summarizes 
the main syntactic notations of CCS). For the restriction
operator, we have chosen to allow a  set of names as a parameter, rather than a
  single name as in the ordinary  CCS syntax; this simplifies 
the manipulation of 
 processes with different orders of
  nested restrictions.
% Also, we do not assume that the uses of \texttt{var} are
%  guarded by \texttt{rec} of the same variable.

%  (Notice the use of
% recursion operator for representing process constants)
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Operator} & \textbf{CCS Notation} & \textbf{HOL term} &
                                                                \textbf{HOL (abbrev.)}\\
\hline
nil & $\textbf{0}$ & \HOLinline{\HOLConst{nil}} & \HOLinline{\HOLConst{nil}} \\
prefix & $u.P$ & \texttt{prefix u P} & \HOLinline{\HOLFreeVar{u}\HOLSymConst{..}\HOLFreeVar{P}} \\
sum & $P + Q$ & \texttt{sum P Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{Q}} \\
parallel & $P \,\mid\, Q$ & \texttt{par P Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{Q}} \\
restriction & $(\nu\;L)\;P$ & \texttt{restr L P} & \HOLinline{\HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{P}}  \\
recursion & $\recu A P$ & \texttt{rec A P} & \HOLinline{\HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{P}}  \\
relabeling & $P\;[r\!f]$ & \texttt{relab P rf} & \HOLinline{\HOLConst{relab} \HOLFreeVar{P} \HOLFreeVar{rf}}  \\
\hline
constant & $A$ & \texttt{var A} & \HOLinline{\HOLConst{var} \HOLFreeVar{A}} \\
invisible action & $\tau$ & \texttt{tau} & \HOLinline{\HOLSymConst{\ensuremath{\tau}}} \\
input action & $a$ & \texttt{label (name a)} & \HOLinline{\HOLConst{In} \HOLFreeVar{a}} \\
output action & $\outC a$ & \texttt{label (coname a)} & \HOLinline{\HOLConst{Out} \HOLFreeVar{a}} \\
\hline
\end{tabular}
\end{center}
%\vspace{-1em}
   \caption{Syntax of CCS operators, constant and actions}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes follows Structural
Operational Semantics (SOS) in Fig.~\ref{f:LTSCCS}:
\begin{alltt}
\HOLTokenTurnstile{} \HOLFreeVar{u}\HOLSymConst{..}\HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P}\hfill\texttt{[PREFIX]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{P} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{Q} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}}\hfill\texttt{[SUM1]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{Q} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}}\hfill\texttt{[SUM2]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{P} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{Q} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{Q}\hfill\texttt{[PAR1]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{Q} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{Q} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{P\sp{\prime}}\hfill\texttt{[PAR2]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLConst{label} \HOLFreeVar{l}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{Q} \HOLTokenTransBegin\HOLConst{label} (\HOLConst{COMPL} \HOLFreeVar{l})\HOLTokenTransEnd \HOLFreeVar{Q\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{P} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{Q} \HOLTokenTransBegin\HOLSymConst{\ensuremath{\tau}}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{Q\sp{\prime}}\hfill\texttt{[PAR3]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{Q} \HOLSymConst{\HOLTokenConj{}} ((\HOLFreeVar{u} \HOLSymConst{=} \HOLSymConst{\ensuremath{\tau}}) \HOLSymConst{\HOLTokenDisj{}} (\HOLFreeVar{u} \HOLSymConst{=} \HOLConst{label} \HOLFreeVar{l}) \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L} \HOLSymConst{\HOLTokenConj{}} \HOLConst{COMPL} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L}) \HOLSymConst{\HOLTokenImp{}}
   \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{Q}\hfill\texttt{[RESTR]}
\HOLTokenTurnstile{} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{Q} \HOLSymConst{\HOLTokenImp{}} \HOLConst{relab} \HOLFreeVar{P} \HOLFreeVar{rf} \HOLTokenTransBegin\HOLConst{relabel} \HOLFreeVar{rf} \HOLFreeVar{u}\HOLTokenTransEnd \HOLConst{relab} \HOLFreeVar{Q} \HOLFreeVar{rf}\hfill\texttt{[RELABELING]}
\HOLTokenTurnstile{} \HOLConst{CCS_Subst} \HOLFreeVar{P} (\HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{P}) \HOLFreeVar{A} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}} \HOLSymConst{\HOLTokenImp{}} \HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{P\sp{\prime}}\hfill\texttt{[REC]}
\end{alltt}

The last rule \texttt{REC} (Recursion)
 says that if we substitute all appearances of variable $A$ in $P$ to
$(\recu A P)$ and the resulting process has a transition to $P'$
with action $u$, then $(\recu A P)$ has the same
transition. In its definition, \texttt{CCS_Subst} is a recursive substutiion function
with the following long definition:
\begin{alltt}
\HOLConst{CCS_Subst} \HOLConst{nil} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=} \HOLConst{nil}
\HOLConst{CCS_Subst} (\HOLFreeVar{u}\HOLSymConst{..}\HOLFreeVar{E}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=} \HOLFreeVar{u}\HOLSymConst{..}\HOLConst{CCS_Subst} \HOLFreeVar{E} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X}
\HOLConst{CCS_Subst} (\HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{E\sb{\mathrm{2}}}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=}
\HOLConst{CCS_Subst} \HOLFreeVar{E\sb{\mathrm{1}}} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{\ensuremath{+}} \HOLConst{CCS_Subst} \HOLFreeVar{E\sb{\mathrm{2}}} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X}
\HOLConst{CCS_Subst} (\HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\parallel}} \HOLFreeVar{E\sb{\mathrm{2}}}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=}
\HOLConst{CCS_Subst} \HOLFreeVar{E\sb{\mathrm{1}}} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{CCS_Subst} \HOLFreeVar{E\sb{\mathrm{2}}} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X}
\HOLConst{CCS_Subst} (\HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} \HOLFreeVar{E}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=} \HOLSymConst{\ensuremath{\nu}} \HOLFreeVar{L} (\HOLConst{CCS_Subst} \HOLFreeVar{E} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X})
\HOLConst{CCS_Subst} (\HOLConst{relab} \HOLFreeVar{E} \HOLFreeVar{f}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=} \HOLConst{relab} (\HOLConst{CCS_Subst} \HOLFreeVar{E} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X}) \HOLFreeVar{f}
\HOLConst{CCS_Subst} (\HOLConst{var} \HOLFreeVar{Y}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=} \HOLKeyword{if} \HOLFreeVar{Y} \HOLSymConst{=} \HOLFreeVar{X} \HOLKeyword{then} \HOLFreeVar{E\sp{\prime}} \HOLKeyword{else} \HOLConst{var} \HOLFreeVar{Y}
\HOLConst{CCS_Subst} (\HOLConst{rec} \HOLFreeVar{Y} \HOLFreeVar{E}) \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X} \HOLSymConst{=}
\HOLKeyword{if} \HOLFreeVar{Y} \HOLSymConst{=} \HOLFreeVar{X} \HOLKeyword{then} \HOLConst{rec} \HOLFreeVar{Y} \HOLFreeVar{E} \HOLKeyword{else} \HOLConst{rec} \HOLFreeVar{Y} (\HOLConst{CCS_Subst} \HOLFreeVar{E} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{X})\hfill{[CCS_Subst_def]}
\end{alltt}

From HOL's viewpoint, these
SOS rules are \emph{inductive 
  definitions} on the tenary relation \HOLinline{\HOLConst{TRANS}} of type ``\HOLinline{(\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS} \HOLTokenTransEnd \ensuremath{\beta} \HOLTyOp{Action} \HOLTokenTransEnd (\ensuremath{\alpha}, \ensuremath{\beta}) \HOLTyOp{CCS} \HOLTokenTransEnd \HOLTyOp{bool}}'', generated by HOL's 
\texttt{Hol_reln} function.

A useful \hl{facility} exploiting the interplay
between HOL4 and Standard ML (that follows an idea by Nesi \cite{Nesi:1992ve})
 is a complex Standard ML function
  taking a CCS process and returning a theorem indicating all
  direct transitions of the process.\footnote{If the input process could yield
    something infinite branching (i.e.~divergent), due to the use of recursion or
    relabeling operators, the program will loop forever without giving the output.
  \hl{Checking if any given process is divergent, is beyond the scope of current work.}}
For instance, we know that the process $(a.0 | \bar{a}.0)$ has three
possible transitions: $(a.0 | \bar{a}.0) \overset{a}{\longrightarrow}
(0 | \bar{a}.0)$, $(a.0 | \bar{a}.0)
\overset{\bar{a}}{\longrightarrow} (a.0 | 0)$ and $(a.0 | \bar{a}.0)
\overset{\tau}{\longrightarrow} (0 | 0)$.
To completely describe all possible transitions of a process, if done manually, the
following facts should be proved: (1) there exists transitions from
$(a.0 | \bar{a}.0)$ (optional); (2) the correctness for each of the
transitions; and (3) the non-existence of other transitions.

For large processes it may be surprisingly hard to manually prove the
non-existence of transitions.  Hence the usefulness of appealing to 
the new  function \texttt{CCS\_TRANS\_CONV}. 
For instance this function
is called on the  process $(a.0 | \bar{a}.0)$ thus:
(\mbox{\color{blue}{\texttt{``}}} is for double-backquotes of HOL
  terms, \mbox{\color{blue}{\texttt{>}}} is HOL's prompt)
\begin{lstlisting}
> CCS_TRANS_CONV ``par (prefix (label (name "a")) nil)
                       (prefix (label (coname "a")) nil)``
\end{lstlisting}
This returns the following theorem, indeed describing all immediate
transitions of the process:
\begin{alltt}
\HOLTokenTurnstile{} \HOLSymConst{\HOLTokenForall{}}\HOLBoundVar{u} \HOLBoundVar{E}.
       \HOLConst{In} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{Out} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLTokenTransBegin\HOLBoundVar{u}\HOLTokenTransEnd \HOLBoundVar{E} \HOLSymConst{\HOLTokenEquiv{}}
       ((\HOLBoundVar{u} \HOLSymConst{=} \HOLConst{In} \HOLStringLit{a}) \HOLSymConst{\HOLTokenConj{}} (\HOLBoundVar{E} \HOLSymConst{=} \HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{Out} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil}) \HOLSymConst{\HOLTokenDisj{}}
        (\HOLBoundVar{u} \HOLSymConst{=} \HOLConst{Out} \HOLStringLit{a}) \HOLSymConst{\HOLTokenConj{}} (\HOLBoundVar{E} \HOLSymConst{=} \HOLConst{In} \HOLStringLit{a}\HOLSymConst{..}\HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{nil})) \HOLSymConst{\HOLTokenDisj{}}
       (\HOLBoundVar{u} \HOLSymConst{=} \HOLSymConst{\ensuremath{\tau}}) \HOLSymConst{\HOLTokenConj{}} (\HOLBoundVar{E} \HOLSymConst{=} \HOLConst{nil} \HOLSymConst{\ensuremath{\parallel}} \HOLConst{nil})\hfill{[Example.ex_A]}
\end{alltt}

% next file: bisim.htex
