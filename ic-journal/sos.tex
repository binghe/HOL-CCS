%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{CCS: the formal version}

In our CCS formalisation, the type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Label}}'' (\texttt{'b} or
$\beta$ is the type variable for actions) accounts for visible actions, divided into input
and output actions, defined by HOL's Datatype package:
\begin{lstlisting}
Datatype: Label = name 'b | coname 'b
End
\end{lstlisting}
The type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}}'' is the
union of all visible actions, plus invisible action $\tau$. It's
defined as an abbreviation of HOL's core type ``\HOLinline{\ensuremath{\alpha} \HOLTyOp{option}}''%
\footnote{\url{https://hol-theorem-prover.org/kananaskis-13-helpdocs/help/src-sml/htmlsigs/optionTheory.html}} instantiated
with the type ``\HOLinline{\ensuremath{\beta} \HOLTyOp{Label}}'':
\begin{lstlisting}
Type Action[pp] = ``:'b Label option``;
\end{lstlisting}
The cardinality of
``\HOLinline{\ensuremath{\beta} \HOLTyOp{Action}}'' (and therefore of all
CCS types built on top of it)
 depends on the choice (or \emph{type-instantiation}) of type variable $\beta$.

The type ``\HOLinline{\ensuremath{(}\ensuremath{\alpha}, \ensuremath{\beta}\ensuremath{)} \HOLTyOp{CCS}}'', accounting for the CCS
syntax\footnote{The order of type variables $\alpha$ and $\beta$
    is arbitrary. Our choice is aligned with other \hl{literature.
For instance,} $\mathrm{CCS}(h,k)$ is the CCS subcalculus that can use at most $h$ constants
and $k$ actions~\cite{gorrieri2017ccs}. To formalize theorems on
such $\mathrm{CCS}(h,k)$, the required CCS type can be retrieved by instantiating the type
variables $\alpha$ and $\beta$ in ``\HOLinline{\ensuremath{(}\ensuremath{\alpha}, \ensuremath{\beta}\ensuremath{)} \HOLTyOp{CCS}}'' with types
having the corresponding cardinalities $h$ and $k$.}, is then defined inductively:
(\texttt{'a} or $\alpha$ is the type variable for recursion variables,
``\HOLinline{\ensuremath{\beta} \HOLTyOp{Relabeling}}'' is the type of all relabeling functions):
\begin{lstlisting}
Datatype: CCS = nil
              | var 'a
              | prefix ('b Action) CCS
              | sum CCS CCS
              | par CCS CCS
              | restr (('b Label) set) CCS
              | relab CCS ('b Relabeling)
              | rec 'a CCS
End
\end{lstlisting}

We have added some grammar support,
 using HOL's powerful pretty printer, to represent CCS
processes in more readable forms (c.f. the column \hl{``\TeX{} outputs''}
of Table \ref{tab:ccsoperator}, which summarizes
the main syntactic notations of CCS). For the restriction
operator, we have chosen to allow a  set of names as a parameter, rather than a
  single name as in the ordinary  CCS syntax; this simplifies
the manipulation of
 processes with different orders of
  nested restrictions.
% Also, we do not assume that the uses of \texttt{var} are
%  guarded by \texttt{rec} of the same variable.

%  (Notice the use of
% recursion operator for representing process constants)
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\hl{\textbf{CCS concept}} & \hl{\textbf{Notation}} & \textbf{HOL term} &
                                             \textbf{HOL abbrev.} & \hl{\textbf{\TeX{} outputs}} \\
\hline
\hl{deadlock} & $\textbf{0}$ & \texttt{nil} & \texttt{nil} & \HOLinline{\HOLConst{\ensuremath{\mathbf{0}}}} \\
prefix & $\mu.P$ & \texttt{prefix u P} & \texttt{u..P} & \HOLinline{\HOLFreeVar{u}\HOLSymConst{\ensuremath{\ldotp}}\HOLFreeVar{P}} \\
\hl{summation} & $P + Q$ & \texttt{sum P Q} & \texttt{P + Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{Q}} \\
parallel \hl{composition} & $P \,\mid\, Q$ & \texttt{par P Q} & \texttt{P || Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{Q}} \\
restriction & $(\nu{}L)\;P$ & \texttt{restr L P} & \texttt{(nu L) P} & \HOLinline{\ensuremath{(\nu}\HOLFreeVar{L}\ensuremath{)} \HOLFreeVar{P}}  \\
recursion & $\recu A P$ & \texttt{rec A P} & \texttt{rec A P} & \HOLinline{\HOLConst{rec} \HOLFreeVar{A} \HOLFreeVar{P}}  \\
relabeling & $P\;[r\!f]$ & \texttt{relab P rf} &\texttt{relab P rf} & \HOLinline{\HOLConst{relab} \HOLFreeVar{P} \HOLFreeVar{rf}}  \\
\hl{constant/variable} & $A$ & \texttt{var A} &\texttt{var A} & \HOLinline{\HOLConst{var} \HOLFreeVar{A}} \\
\hline
invisible action & $\tau$ & \texttt{tau} & \texttt{tau} & \HOLinline{\HOLSymConst{\ensuremath{\tau}}} \\
input action & $a$ & \texttt{label (name a)} &\texttt{In(a)} & \HOLinline{\HOLConst{\HOLTokenInputAct} \HOLFreeVar{a}} \\
output action & $\outC a$ & \texttt{label (coname a)} & \texttt{Out(a)} & \HOLinline{\HOLConst{\HOLTokenOutputAct} \HOLFreeVar{a}} \\
\hline
\hl{variable substitution} & $E\{E'/X\}$ & \texttt{CCS_Subst E E' X} &
                                           \texttt{[E'/X]  E} & \HOLinline{\ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \HOLFreeVar{E}} \\
\hl{transition} & $P\overset{\mu}{\longrightarrow}Q$
                       & \texttt{TRANS P u Q} & \texttt{P ---u-> Q} & \HOLinline{\HOLFreeVar{P} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{Q}} \\
\hl{weak transition} & $P\overset{\mu}{\Longrightarrow}Q$
                       & \texttt{WEAK\_TRANS P u Q} & \texttt{P ==u=> Q} & \HOLinline{\HOLFreeVar{P} \HOLTokenWeakTransBegin\HOLFreeVar{u}\HOLTokenWeakTransEnd \HOLFreeVar{Q}} \\
\hl{$\epsilon$--transition} & $P\overset{\epsilon}{\Longrightarrow}Q$
                       & \texttt{EPS P Q} & \texttt{EPS P Q} & \HOLinline{\HOLFreeVar{P} \HOLSymConst{\HOLTokenEPS} \HOLFreeVar{Q}} \\
\hline
\end{tabular}
\end{center}
   \caption{Syntax of \hl{various CCS concepts in HOL}}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes follows Structural
Operational Semantics (SOS) in Fig.~\ref{f:LTSCCS}:\footnote{All
  formal theorems and definitions (their \TeX{} code) in this paper
  are generated directly from HOL4. By default, all theorems are fully
  specialised, removing outermost universal quantifiers.}
\begin{alltt}
\HOLTokenTurnstile{} \HOLFreeVar{u}\HOLSymConst{\ensuremath{\ldotp}}\HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E}\hfill\texttt{[PREFIX]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[SUM1]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[SUM2]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{E\sp{\prime}}\hfill\texttt{[PAR1]}
\HOLTokenTurnstile{} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\HOLTokenImp{}} \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{E\sb{\mathrm{1}}}\hfill\texttt{[PAR2]}
\end{alltt}

\begin{equation}
\infer[\HOLRuleName{PAR3}]{\HOLinline{\HOLFreeVar{E} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLSymConst{\ensuremath{\tau}}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{\mid}} \HOLFreeVar{E\sb{\mathrm{2}}}}}{\HOLinline{\HOLFreeVar{E} \HOLTokenTransBegin\HOLConst{label} \HOLFreeVar{l}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}}&\HOLinline{\HOLFreeVar{E\sp{\prime}} \HOLTokenTransBegin\HOLConst{label} \ensuremath{(}\HOLConst{COMPL} \HOLFreeVar{l}\ensuremath{)}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{2}}}}}
\end{equation}

\begin{equation}
\infer[\HOLRuleName{RESTR}]{\HOLinline{\ensuremath{(\nu}\HOLFreeVar{L}\ensuremath{)} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \ensuremath{(\nu}\HOLFreeVar{L}\ensuremath{)} \HOLFreeVar{E\sp{\prime}}}}{\HOLinline{\HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}}}&\HOLinline{\HOLFreeVar{u} \HOLSymConst{\ensuremath{=}} \HOLSymConst{\ensuremath{\tau}} \HOLSymConst{\HOLTokenDisj{}} \HOLFreeVar{u} \HOLSymConst{\ensuremath{=}} \HOLConst{label} \HOLFreeVar{l} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L} \HOLSymConst{\HOLTokenConj{}} \HOLConst{COMPL} \HOLFreeVar{l} \HOLSymConst{\HOLTokenNotIn{}} \HOLFreeVar{L}}}
\end{equation}

\begin{equation}
\infer[\HOLRuleName{RELABELING}]{\HOLinline{\HOLConst{relab} \HOLFreeVar{E} \HOLFreeVar{rf} \HOLTokenTransBegin\HOLConst{relabel} \HOLFreeVar{rf} \HOLFreeVar{u}\HOLTokenTransEnd \HOLConst{relab} \HOLFreeVar{E\sp{\prime}} \HOLFreeVar{rf}}}{\HOLinline{\HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sp{\prime}}}}
\end{equation}

\begin{equation}
\infer[\HOLRuleName{REC}]{\HOLinline{\HOLConst{rec} \HOLFreeVar{X} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}}}{\HOLinline{\ensuremath{[}\HOLConst{rec} \HOLFreeVar{X} \HOLFreeVar{E}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \HOLFreeVar{E} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E\sb{\mathrm{1}}}}}
\end{equation}

The last rule \texttt{REC} (Recursion)
 says that if we substitute all \hl{occurrences of the} variable $A$ in $P$ to
$(\recu A P)$ and the resulting process has a transition to $P'$
with action $u$, then $(\recu A P)$ has the same
transition. Here, ``\HOLinline{\ensuremath{[}\HOLConst{rec} \HOLFreeVar{X} \HOLFreeVar{E}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \HOLFreeVar{E}}'' is \hl{an abbreviation}
of ``\HOLinline{\HOLConst{CCS_Subst} \HOLFreeVar{E} \ensuremath{(}\HOLConst{rec} \HOLFreeVar{X} \HOLFreeVar{E}\ensuremath{)} \HOLFreeVar{X}}'', where \HOLinline{\HOLConst{CCS_Subst}} is a
recursive function substituting all appearences of a free variable
into another CCS term.
For most CCS operators \HOLinline{\HOLConst{CCS_Subst}} just recursively goes into a deeper
level without changing anything, e.g.
\begin{alltt}
\HOLTokenTurnstile{} \ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \ensuremath{(}\HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{+}} \HOLFreeVar{E\sb{\mathrm{2}}}\ensuremath{)} \HOLSymConst{\ensuremath{=}} \ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \HOLFreeVar{E\sb{\mathrm{1}}} \HOLSymConst{\ensuremath{+}} \ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \HOLFreeVar{E\sb{\mathrm{2}}}\hfill{[CCS_Subst_sum]}
\end{alltt}
The only two insteresting cases are for the recursion operator and
recursion variables:
\begin{alltt}
\HOLTokenTurnstile{} \ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \ensuremath{(}\HOLConst{rec} \HOLFreeVar{Y} \HOLFreeVar{E}\ensuremath{)} \HOLSymConst{\ensuremath{=}} \HOLKeyword{if} \HOLFreeVar{Y} \HOLSymConst{\ensuremath{=}} \HOLFreeVar{X} \HOLKeyword{then} \HOLConst{rec} \HOLFreeVar{Y} \HOLFreeVar{E} \HOLKeyword{else} \HOLConst{rec} \HOLFreeVar{Y} \ensuremath{(}\ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \HOLFreeVar{E}\ensuremath{)}\hfill{[CCS_Subst_rec]}
\HOLTokenTurnstile{} \ensuremath{[}\HOLFreeVar{E\sp{\prime}}\ensuremath{/}\HOLFreeVar{X}\ensuremath{]} \ensuremath{(}\HOLConst{var} \HOLFreeVar{Y}\ensuremath{)} \HOLSymConst{\ensuremath{=}} \HOLKeyword{if} \HOLFreeVar{Y} \HOLSymConst{\ensuremath{=}} \HOLFreeVar{X} \HOLKeyword{then} \HOLFreeVar{E\sp{\prime}} \HOLKeyword{else} \HOLConst{var} \HOLFreeVar{Y}\hfill{[CCS_Subst_var]}
\end{alltt}
\hl{Intuitively, the variable substitutions only happens on \emph{free}
variables: the variable $Y$ in} ``\HOLinline{\HOLConst{rec} \HOLFreeVar{Y} \HOLFreeVar{E}}'' \hl{is
considered \emph{bound} and the substitution process ignores it if $Y$ is
being substituted. The actual substitution happens in case of}
``\HOLinline{\HOLConst{var} \HOLFreeVar{Y}}'' if $Y$ is being substituted (and if \HOLinline{\HOLConst{CCS_Subst}}
can actually reach it).

From \hl{the point of view of HOL4, SOS rules are actually} \emph{inductive
  definitions} \hl{of the ternary} relation \HOLinline{\HOLConst{TRANS}} of type ``\HOLinline{\ensuremath{(}\ensuremath{\alpha}, \ensuremath{\beta}\ensuremath{)} \HOLTyOp{CCS} \HOLTokenTransEnd \ensuremath{\beta} \HOLTyOp{Action} \HOLTokenTransEnd \ensuremath{(}\ensuremath{\alpha}, \ensuremath{\beta}\ensuremath{)} \HOLTyOp{CCS} \HOLTokenTransEnd \HOLTyOp{bool}}'', generated by HOL's
\texttt{Hol_reln} function.

A useful facility exploiting the interplay
between HOL4 and Standard ML (that follows an idea by Nesi \cite{Nesi:1992ve})
 is a complex Standard ML function
  taking a CCS process and returning a theorem indicating all
  direct transitions of the process.\footnote{If the input process \hl{are
 infinite branching, the function will not terminate}.}
For instance, we know that the process $(a.\nil | \bar{a}.\nil)$ has three
possible transitions: $(a.\nil | \bar{a}.\nil) \overset{a}{\longrightarrow}
(\nil | \bar{a}.\nil)$, $(a.\nil | \bar{a}.\nil)
\overset{\bar{a}}{\longrightarrow} (a.\nil | \nil)$ and $(a.\nil | \bar{a}.\nil)
\overset{\tau}{\longrightarrow} (\nil | \nil)$.
To completely describe all possible transitions of a process, if done manually, the
following two facts must be proved: \hl{(1) there exist indeed three
  transitions mentioned above; (2) there exists no other
  transition. The first part can be easily proved by SOS rules, while
  the second part can only be proved by \texttt{TRANS\_cases}. (TODO)}

For large CCS processes it is surprisingly \hl{tedious} to manually derive
all the possible transitions and prove the non-existence of others,
\hl{which shows the usefulness of appealing to an ML function
\texttt{CCS\_TRANS\_CONV} who is designed to automate the whole process.
For instance, calling it on $(a.\nil | \bar{a}.\nil)$ the function returns the
following theorem which describes all the transitions (just one-step) of the process:}
\begin{alltt}
\HOLTokenTurnstile{} \HOLConst{\HOLTokenInputAct} \HOLStringLit{a}\HOLSymConst{\ensuremath{\ldotp}}\HOLConst{\ensuremath{\mathbf{0}}} \HOLSymConst{\ensuremath{\mid}} \HOLConst{\HOLTokenOutputAct} \HOLStringLit{a}\HOLSymConst{\ensuremath{\ldotp}}\HOLConst{\ensuremath{\mathbf{0}}} \HOLTokenTransBegin\HOLFreeVar{u}\HOLTokenTransEnd \HOLFreeVar{E} \HOLSymConst{\HOLTokenEquiv{}}
   \ensuremath{(}\HOLFreeVar{u} \HOLSymConst{\ensuremath{=}} \HOLConst{\HOLTokenInputAct} \HOLStringLit{a} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{=}} \HOLConst{\ensuremath{\mathbf{0}}} \HOLSymConst{\ensuremath{\mid}} \HOLConst{\HOLTokenOutputAct} \HOLStringLit{a}\HOLSymConst{\ensuremath{\ldotp}}\HOLConst{\ensuremath{\mathbf{0}}} \HOLSymConst{\HOLTokenDisj{}} \HOLFreeVar{u} \HOLSymConst{\ensuremath{=}} \HOLConst{\HOLTokenOutputAct} \HOLStringLit{a} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{=}} \HOLConst{\HOLTokenInputAct} \HOLStringLit{a}\HOLSymConst{\ensuremath{\ldotp}}\HOLConst{\ensuremath{\mathbf{0}}} \HOLSymConst{\ensuremath{\mid}} \HOLConst{\ensuremath{\mathbf{0}}}\ensuremath{)} \HOLSymConst{\HOLTokenDisj{}}
   \HOLFreeVar{u} \HOLSymConst{\ensuremath{=}} \HOLSymConst{\ensuremath{\tau}} \HOLSymConst{\HOLTokenConj{}} \HOLFreeVar{E} \HOLSymConst{\ensuremath{=}} \HOLConst{\ensuremath{\mathbf{0}}} \HOLSymConst{\ensuremath{\mid}} \HOLConst{\ensuremath{\mathbf{0}}}
\end{alltt}

% next file: bisim.htex
