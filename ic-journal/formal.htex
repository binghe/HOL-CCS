%%%% -*- Mode: LaTeX; -*-

\newcommand\fun{{\to}}
\newcommand\prd{{\times}}
\newcommand{\ty}[1]{\textsl{#1}}
\newcommand\conj{\ \wedge\ }
\newcommand\disj{\ \vee\ }
\newcommand\imp{ \Rightarrow }
\newcommand\eqv{\ \equiv\ }
\newcommand\vbar{\mid}
\newcommand\turn{\ \vdash\ } % FIXME: "\ " resultgs in extra space
\newcommand\hilbert{\varepsilon}
\newcommand{\uquant}[1]{\forall #1.\ }
\newcommand{\equant}[1]{\exists #1.\ }
\newcommand{\hquant}[1]{\hilbert #1.\ }
\newcommand{\iquant}[1]{\exists ! #1.\ }
\newcommand{\lquant}[1]{\lambda #1.\ }
\newcommand{\ml}[1]{\mbox{{\def\_{\char'137}\texttt{#1}}}}
\newcommand{\con}[1]{\mathrm{#1}}

\newcommand\bool{\ty{bool}}
\newcommand\num{\ty{num}}
\newcommand\ind{\ty{ind}}
\newcommand\lst{\ty{list}}

\providecommand{\T}{\con{T}}
\renewcommand{\T}{\con{T}}
\newcommand\F{\con{F}}
\newcommand\OneOne{\con{One\_One}}
\newcommand\OntoSubset{\con{Onto\_Subset}}
\newcommand\Onto{\con{Onto}}
\newcommand\TyDef{\con{Type\_Definition}}

\section{The formalisation}
\label{s:for}

We highlight here a comprehensive formalisation of CCS in the HOL theorem prover
(HOL4)~\cite{Melham:1993vl,slind2008brief}, with a focus towards the
theory (and formal proofs) of the unique solution of
equations/contractions theorems mentioned in Section~\ref{s:eq} and
\ref{s:mcontr}.
All proof scripts are available as part of HOL's official
examples\footnote{\url{https://github.com/HOL-Theorem-Prover/HOL/tree/master/examples/CCS}}.
The work so far consists of about 24,000 lines (1MB) of code in total,
in which about 5,000 lines were derived from the early work of Monica
Nesi~\cite{Nesi:1992ve} on HOL88, with major modifications.

Higher Order Logic (HOL)~\cite{hollogic} traces
its roots back to the
\emph{Logic of Computable Functions
  (LCF)}~\cite{gordon1979edinburgh,milner1972logic}
by Robin Milner and others
since 1972. It is a variant of
Churchâ€™s Simple Theory of Types (STT)~\cite{church1940formulation},
plus a higher order version of Hilbert's choice operator $\varepsilon$,
Axiom of Infinity, and Rank-1 (prenex) polymorphism.
HOL4 has implemented the original HOL, 
while some other theorem provers in the HOL family (e.g.~Isabelle/HOL) have
certain extensions.
%  (they made the formal language more powerful,
% but they also bring the possibilities that the entire logic becomes
% inconsistent). 
Indeed, HOL has considerably simpler logical
foundations than most other theorem provers.
As a consequence, theories and proofs verified in HOL are easier to understand
 for people who are not familiar with more advanced dependent type % editorial
 theories, e.g. the Calculus of Constructions implemented in Coq.

HOL4 is implemented in Standard ML, and
 the same programming language
plays three different roles:
\begin{itemize}
\item The underlying implementation language for the core HOL engine;
\item The language in which proof tactics are implemented;
\item The interface language of the HOL proof scripts and interactive shell.
\end{itemize}
Moreover, using the same language HOL4 users can write complex automatic
verification tools by calling HOL's theorem proving
facilities. The formal proofs of the CCS theorems that we have carried
out 
are mostly done in a manner that closely follows
their paper proofs, with minimal automatic proof searching.

\subsection{Higher Order Logic (HOL)}

HOL is a formal system of typed logical terms. The types are expressions that denote sets (in the
universe $\mathcal{U}$). HOL type system is much simpler than those
based on dependent types and other type theories. There are four kinds of types in the HOL
logic, as illustrated in Fig. \ref{fig:hol-types} for its BNF
grammar. In HOL, the standard atomic types \emph{bool} and \emph{ind}
 denote, respectively, the distinguished two-element set $\mathbf{2}$ and the
distinguished infinite set $\mathbf{I}$.

\newlength{\ttX}
\settowidth{\ttX}{\tt X}
\newcommand{\tyvar}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,0){\makebox(0,0)[b]{\footnotesize type variables}}
\put(0,1.5){\vector(0,1){4.5}}
\end{picture}}
\newcommand{\tyatom}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,2.3){\makebox(0,0)[b]{\footnotesize atomic types}}
\put(.5,3.3){\vector(0,1){2.6}}
\end{picture}}
\newcommand{\funty}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,1.5){\makebox(0,0)[b]{\footnotesize function types}}
\put(.5,0){\makebox(0,0)[b]{\footnotesize (domain $\sigma_1$, codomain $\sigma_2$)}}
\put(1,2.5){\vector(0,1){3.5}}
\end{picture}}
\newcommand{\cmpty}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(2,3.3){\makebox(0,0)[b]{\footnotesize compound types}}
\put(1.9,4.5){\vector(0,1){1.5}}
\end{picture}}

\begin{figure}[h]
\begin{equation*}
\sigma\quad ::=\quad {\mathord{\mathop{\alpha}\limits_{\tyvar}}}
        \quad\mid\quad{\mathord{\mathop{c}\limits_{\tyatom}}}
        \quad\mid\quad\underbrace{(\sigma_1, \ldots , \sigma_n){op}}_{\cmpty}
        \quad\mid\quad\underbrace{\sigma_1\fun\sigma_2}_{\funty}
\end{equation*}
   \caption{HOL's type grammar}
   \label{fig:hol-types}
\end{figure}

HOL terms represent elements of the
sets denoted by their types. There are four kinds of HOL terms,
which can be described (in simplified forms) by the BNF grammar in
Fig.~\ref{fig:hol-terms}. (See~\cite{hollogic} for a complete
description of HOL, including the primitive derivative rules to be
mentioned below.)

\settowidth{\ttX}{\tt X}
\newcommand{\var}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,0){\makebox(0,0)[b]{\footnotesize variables}}
\put(0,1.5){\vector(0,1){4.5}}
\end{picture}}
\newcommand{\const}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,2.3){\makebox(0,0)[b]{\footnotesize constants}}
\put(.5,3.5){\vector(0,1){2.4}}
\end{picture}}
\newcommand{\app}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,1.5){\makebox(0,0)[b]{\footnotesize function applications}}
\put(.5,0){\makebox(0,0)[b]{\footnotesize (function $t$, argument $t'$)}}
\put(0.5,2.5){\vector(0,1){3.5}}
\end{picture}}
\newcommand{\abs}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(1,3.3){\makebox(0,0)[b]{\footnotesize $\lambda$-abstractions}}
\put(0.7,4.5){\vector(0,1){1.5}}
\end{picture}}

\begin{figure}[h]
\begin{equation*}
t \quad ::=\quad {\mathord{\mathop{x}\limits_{\var}}}
        \quad\mid\quad{\mathord{\mathop{c}\limits_{\const}}}
        \quad\mid\quad\underbrace{t\ t'}_{\app}
        \quad\mid\quad\underbrace{\lambda x .\ t}_{\abs}
\end{equation*}
   \caption{HOL's term grammar}
   \label{fig:hol-terms}
 \end{figure}

The deductive system of HOL is specified by eight primitive
derivative rules:
\begin{enumerate}
\item Assumption introduction (\texttt{ASSUME});
\item Reflexivity (\texttt{REFL});
\item $\beta$-conversion (\texttt{BETA\_CONV});
\item Substitution (\texttt{SUBST});
\item Abstraction (\texttt{ABS});
\item Type instantiation (\texttt{INST\_TYPE});
\item Discharging an assumption (\texttt{DISCH});
\item Modus Ponens (\texttt{MP}).
\end{enumerate}
All proofs are eventually reduced to applications of the above rules,
which also give the semantics of two fundamental % editorial
logical connectives, equality ($=$) and implication
($\Rightarrow$). The remaining logical connectives and first-order
quantifiers, including the logical true (\HOLtm{T}) and false (\HOLtm{F}), are
further defined as $\lambda$-functions: 
\begin{equation*}
\begin{array}{l}
\turn \T \HOLTokenDefEquality ((\lquant{x_{\ty{bool}}}x) =
               (\lquant{x_{\ty{bool}}}x))    \\
\turn \forall \HOLTokenDefEquality \lquant{P_{\alpha\fun\ty{bool}}} P =
                    (\lquant{x}\T ) \\
\turn \exists \HOLTokenDefEquality \lquant{P_{\alpha\fun\ty{bool}}} P({\hilbert}\, P) \\
\turn \F \HOLTokenDefEquality \uquant{b_{\ty{bool}}} b  \\
\turn \neg \HOLTokenDefEquality \lquant{b} b \imp \F \\
\turn {\wedge}  \HOLTokenDefEquality  \lquant{b_1\ b_2}\uquant{b} (b_1\imp (b_2 \imp b)) \imp b \\
\turn {\vee} \HOLTokenDefEquality \lquant{b_1\ b_2}\uquant{b} (b_1 \imp b)\imp ((b_2 \imp b) \imp b) \\
\turn \OneOne \HOLTokenDefEquality \lquant{f_{\alpha \fun\beta}}\uquant{x_1\ x_2}
                    (f\ x_1 = f\ x_2)  \imp (x_1 = x_2) \\
\turn \Onto \HOLTokenDefEquality \lquant{f_{\alpha\fun\beta}}
                  \uquant{y}\equant{x} y = f\ x \\
\turn \TyDef \HOLTokenDefEquality \lambda P_{\alpha\fun\ty{bool}}\
                  rep_{\beta\fun\alpha}.\;
                  \OneOne\ rep \ \wedge{}\  (\uquant{x}P x = (\equant{y} x = rep\ y))
\end{array}
\end{equation*}
The last logical constant,
$\TyDef$, can be used to define new HOL types as bijections of
subsets of existing types~\cite{Melham:1989dk}.
HOL \texttt{Datatype} package~\cite{Melham:1991, holdesc} automates
this tedious process, and can be used for defining the 
types needed for CCS.
%
Finally, the whole HOL \emph{standard} theory is based on the
following four axioms:\footnote{HOL is strictly
  weaker than ZFC (the Zermelo-Frankel set theory with the
Axiom of Choice), thus not all theorems valid in ZFC can be formalised
in HOL. (See~\cite{hollogic} for more details.)}
\begin{equation*}
\begin{array}{@{}l@{\qquad}l}
\mbox{\texttt{BOOL\_CASES\_AX}} &\vdash \uquant{b} (b = \T )\ \vee \ (b = \F )\\
\mbox{\texttt{ETA\_AX}} &
\vdash \uquant{f_{\alpha\fun\beta}}(\lquant{x}f\ x) = f\\
\mbox{\texttt{SELECT\_AX}} &
\vdash \uquant{P_{\alpha\fun\ty{bool}}\ x} P\ x \imp P({\hilbert}\ P)\\
\mbox{\texttt{INFINITY\_AX}}&
\vdash \equant{f_{\ind\fun \ind}} \OneOne \ f \conj \neg(\Onto \ f)\\
\end{array}
\end{equation*}

Usually the above four axioms are the only axioms allowed
in conventional formalisation projects in HOL4: adding new axioms
manually may break logical consistency.

% next file: sos.htex
