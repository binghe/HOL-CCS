%%%% -*- Mode: LaTeX -*-

\section{The \multivariate formalisation}
\label{sec:multivariate}

In this section, the formalisation of the \multivariate (general)
cases of Milner's ``unique solution of equations (for $\sim$)''
(Theorem~\ref{t:Mil89s1}) and our ``unique solution of rooted
contractions'' (Theorem~\ref{t:rcontraBisimulationU}) is
described.
We choose these two theorems because they both depend on the same
concept of ``weakly guarded contexts'', and Lemma~\ref{lem:milner313}.
\hl{This work is entirely new} after~\cite{EPTCS276.10}.
It is accumulative, completely based on the
existing formal framework in the sense that, neither the CCS datatype nor
the SOS rules need to be changed.

The central problem of the \multivariate formalisation is the
representation of CCS equations (expressions, contexts).
Recall the univariate formalisation, $\lambda$-functions (of type
$CCS\rightarrow CCS$) are used to represent univariate CCS
equations, and variable substitutions are simply done by
calling $\lambda$-functions on the target CCS terms.
This idea cannot be extended to the \multivariate case, as
we don't have a fixed number of variables to deal with.

Modern literature (i.e.~after Milner) usually consider the $X_i$ of
a system of equations $\{X_i = E_i\}_{i\in I}$ (c.f. Def.~\ref{def:equation}) as an
\emph{equation variable (or process variable)}~\citep[p.~102]{Gorrieri:2015jt}
\emph{outside} of the CCS syntax, and treat $E_i$ as an \emph{open} expression
built with CCS operators which may contain some occurrences of $X_i$.
For a formal point of view, this means we either need to define a
whole new datatype (with extra equation variables) in which each CCS
opeartor must be duplicated, or we should add equation variables as a
new primitive (e.g.~\texttt{Var X}) in the existing CCS type beside
the agent variables (e.g.~\texttt{var X}). Then the substitution of equation
variables in $E_i\{\til P/\til X\}$ would be simply the \emph{syntactic substitution} of
each occurrence of $X_i$ in $E_i$ with the corresponding $P_i$. Notice that, in
either case the \emph{disjointness} between equation variables and
agent variables (or constants) is obvious and syntactically
guaranteed. However, neither solution is elegant: dealing with another CCS-like type makes the
whole formalisation work ugly and we loose the (possibly valuable) bisimilarity concepts and
transitional semantics of CCS expressions; on the other hand,
modifying the CCS datatype to just support the formalisation of
unique-solution theorems is also not acceptable.

In this project, we have chosen to adopt Milner's original approach,
which is also the most elegant way: reusing \emph{free} agent variables
(i.e. undefined constants) as equation variables, then the variable
substitution function used in SOS rules [\texttt{REC}] can be also
used for substituting eqaution variables.
However, this approach brings us great difficulities in proving many
fundamental lemmas, mostly due to the variable capture issues between
equation variables and agent variables.

\subsection{Free and bound variables}

Recall the beginning of Section~\ref{s:eq},
the CCS syntax leaves the syntactic possibility that an
agent variable $A$ occurs outside the recursion operator of the same
variable. In Milner's original book chapter~\cite{milner1990operational}, the
variables which occur in Recursion (such as $X$ in $\recu X E$) are
called \emph{bound} variables, while those which occur unbound are called
\emph{free} variables. We denote the set of all bound variables of a
given CCS term $E$ as $\bv{E}$ (or \HOLtm[m\;]{BV E} in HOL), and the set of all free
variables as $\fv{E}$ (or \HOLtm[m\;]{FV E} in HOL). Both \HOLtm{BV} and \HOLtm{FV} have the
type ``\HOLty[of]{FV}'', i.e. functions taking CCS terms returning sets of
variables (of type \HOLty{:'a}).
Milner didn't give their definitions explicitly. However, one can
imagine that, for most CCS operators they just pass into
subterms without collecting anything (and $\nil$ gives $\emptyset$).
The only interesting cases are Recursion and agent variables, shown below: (Here \texttt{DELETE}
and \texttt{INSERT} are set-theoretic operators of HOL's
\texttt{pred_set} theory.)
\begin{center}
\begin{tabular}{|l|l|}
\hline
\HOLthm[def]{CCS.FV_var} & \HOLthm[def]{CCS.FV_rec} \\
\HOLthm[def]{CCS.BV_var} & \HOLthm[def]{CCS.BV_rec} \\
\hline
\end{tabular}
\end{center}
Furthermore, we say $E$ is a process, denoted by \HOLtm{IS_PROC E}, if
it contains no free variables, i.e. $\fv{E} = \emptyset$:
\begin{alltt}
\HOLthm[def,>>3]{CCS.IS_PROC_def}\hfill{[IS_PROC_def]}
\end{alltt}

Notice that, for any CCS expression, the set of free and bound
variables may not be disjoint, e.g. $X + \recu X E$.
More importantly, when going
from a CCS expression to its sub-expressions, the set of free
variables may increase, while the set of bound variables always
decrease. For instance, $\fv{\recu X (\mu.X)} = \emptyset$, while
$\fv{\mu.X} = \{X\}$. This property of $\fv{\cdot}$ brings greatly
difficulities when doing proofs on CCS transitions. As an evidence,
we prove the following fundamental result about $\fv{\cdot}$:

\begin{proposition}
\label{prop:transFV}
The derivatives of a process are themselves processes, i.e.
if $E \arr{\mu} E'$ and $\fv{E} = \emptyset$, then $\fv{E'} =
\emptyset$. Or, formally:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_PROC}\hfill{[TRANS_PROC]}
\end{alltt}
\end{proposition}

\begin{proof}
Milner said it can be proven by ``an easy action
induction''~\cite{milner1990operational}. However this is not true at all.
%
To see things more clearly, we try to prove a stronger result,
i.e. the set of free variables decreases through derivations:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_FV}\hfill{[TRANS_FV]}
\end{alltt}

From HOL's viewpoint, the so-called ``action induction'' is actually a higher-order \hl{application}
of the following \emph{induction principle} generated together with SOS
rules: (which essentially says \hl{that} \HOLtm{TRANS} is the smallest relation
satisfying SOS rules.)
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_IND}\hfill{[TRANS_IND]}
\end{alltt}
The above long theorem has the form \HOLtm[m\;]{!P. X ==> !E u E'. TRANS E
  u E' ==> P E u E'} (with $a_0, a_1, a_2$ renamed), where the
outermost universal quantifier $P$ is a higher-order
proposition (about $E$, $\mu$ and $E'$), and $X$ is another higher-order
proposition about $P$.
What we are trying to prove is actually in the form of
\HOLtm[m\;]{!E u E'. TRANS E u E' ==> P E u E'}, where
\HOLtm[m\;]{P = \E u E'. FV E' SUBSET FV E}. Thus, if we can prove
$X$ under this specific $P$, by Modus Ponens (MP) the original proof completes.
\hl{\emph{This is the whole idea of action induction.}}
Now the original goal can be reduced to several conjunct
subgoals, each corresponding to one SOS rule. For instance, in
\hl{the subgoal for \texttt{SUM1} we need to prove}
$\fv{E_1} \subseteq \fv{E} \Longrightarrow
\fv{E_1} \subseteq \fv{E + E'}$, but this obviously holds: $\fv{E}
\subseteq \fv{E + E'} = \fv{E} \cup \fv{E'}$. Eventually we have only
the following goal left: (the term above the dash line is the goal,
those below the line are assumptions)
\begin{alltt}
        \HOLtm{FV E' SUBSET FV E DELETE X}
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
\end{alltt}
Notice that, \HOLtm[m\;]{FV E DELETE X = FV (rec X E)}, so
this is indeed the consequence of action induction on the Recursion.
Here the problem is, we know nothing about
\HOLtm[m\;]{FV ([rec X E/X] E)}. To further proceed, we need to prove
some other (easier) lemmas. First, the next lemma can be easily proven
by doing induction on $E$ and basic set-theoretic facts:
\begin{alltt}
\HOLthm[nosp]{CCS.FV_SUBSET}\hfill{[FV_SUBSET]}
\end{alltt}
Then, if we took $E' = \recu X E$ in the above lemma, we get
\HOLtm[m\;]{FV ([rec X E/X] E) SUBSET FV E UNION
  FV (rec X E)} $=$ \HOLtm[m\;]{FV E UNION (FV E DELETE X)} $=$
\HOLtm[m\;]{FV E}, i.e. the following lemma:
\begin{alltt}
\HOLthm[nosp]{CCS.FV_SUBSET_REC}\hfill{[FV_SUBSET_REC]}
\end{alltt}
Now we can enrich the assumptions of the current proof goal with above
lemma, then obtain \HOLtm{FV E' SUBSET FV E} by
from the transitivity of $\subseteq$:
\begin{alltt}
        \HOLtm{FV E' SUBSET FV E DELETE X}
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
    1.  \HOLtm{FV ([rec X E/X] E) SUBSET FV E}
    2.  \HOLtm{FV E' SUBSET FV E}
\end{alltt}
Knowing \HOLtm{FV E' SUBSET FV E} we cannot prove \HOLtm{FV
  E' SUBSET FV E DELETE X}. However, if we knew \HOLtm{X
  NOTIN (FV E')}, then \HOLtm{FV E' DELETE X = FV E'}, and 
\HOLtm{FV E' SUBSET FV E ==> FV E' DELETE X SUBSET FV E
  DELETE X}, no matter if \HOLtm{X IN FV E} or not, and the proof
completes. Thus it remains to prove that
\begin{alltt}
        \HOLtm{X NOTIN FV E'}
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
    1.  \HOLtm{FV ([rec X E/X] E) SUBSET FV E}
    2.  \HOLtm{FV E' SUBSET FV E}
\end{alltt}
Now we try proof by contradiction (\emph{reductio ad absurdum}): if
the goal does not hold, i.e.
\HOLtm{X IN FV E'}, then by assumption 0 we have \HOLtm{X IN FV ([rec X
  E/X] E)}:
\begin{alltt}
        F
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
    1.  \HOLtm{FV ([rec X E/X] E) SUBSET FV E}
    2.  \HOLtm{FV E' SUBSET FV E}
    3.  \HOLtm{X IN FV E'}
    4.  \HOLtm{X IN FV ([rec X E/X] E)}
\end{alltt}
But this is impossible, because all free occurrences of $X$ in $E$ now become
bound in the form of $\recu X E$. In fact, the following lemma can be
easily proven by induction on $E$:
\begin{alltt}
\HOLthm[nosp]{CCS.NOTIN_FV_lemma}\hfill{[NOTIN_FV_lemma]}
\end{alltt}
Adding the above lemma (taking $E' = E$) into the assumption list immediately causes
a contradiction with assumption 4, and the proof finally completes.
\end{proof}

Without the above result, the proof of Milner's ``unique solution of
equations'' theorem (for $\sim$) cannot complete. Comparing with the
above proof, the proof of the similar result for bound variables is much easier:
\begin{proposition}
\label{prop:transBV}
if $E \arr{\mu} E'$ then $\bv{E'} \subseteq \bv{E}$, or formally:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_BV}\hfill{[TRANS_BV]}
\end{alltt}
\end{proposition}
\begin{proof}
Following the proof of Prop.~\ref{prop:transFV}, we do action
induction on $E \arr{\mu} E'$ and simplify all subgoals by set-theoretic
facts. The only subgoal left is:
\begin{alltt}
        \HOLtm{BV E' SUBSET X INSERT BV E}
   ------------------------------------
    0.  \HOLtm{BV E' SUBSET BV ([rec X E/X] E)}
\end{alltt}
Notice the difference with the proof of Prop.~\ref{prop:transFV}: now
we have \texttt{INSERT} in place of \texttt{DELETE}. Then, we directly
use the assumption and the transitivity of $\subseteq$ and try to
prove the following goal instead:
\begin{alltt}
        \HOLtm{BV ([rec X E/X] E) SUBSET X INSERT BV E}
   ------------------------------------
    0.  \HOLtm{BV E' SUBSET BV ([rec X E/X] E)}
\end{alltt}
But this is an easy goal, due to the following lemma which can be
easily proven by induction on $E$:
\begin{alltt}
\HOLthm[nosp]{CCS.BV_SUBSET}\hfill{[BV_SUBSET]}
\end{alltt}
Taking $E ' = \recu X E$ in the above lemma, we have
    \HOLtm[m\;]{BV ([rec X E/X] E) SUBSET BV E UNION BV (rec X E)},
    the right side equals to \HOLtm[m\;]{BV E UNION (X INSERT BV E)} $=$
    \HOLtm[m\;]{X INSERT BV E}. The proof easily completes.
\end{proof}

\subsection{\Multivariate substitutions}

There are two ways to represent (and actually do) the \multivariate
substitution of $E\{\til P/\til X\}$ which substitutes each possibly
occurrences of free variables $X_i$ in $E$ with the corresponding
$P_i$: (1) iterately applying the existing univariate
\HOLtm[-SUB]{CCS_Subst}; (2) defining a new \multivariate substitution
function. In any case, we (reasonably) assume that all $X_i$ are
distinct with each other. On the other hand, there is the syntactic
possibility that $\til P$ again contains variables from $\til X$, thus
different orders of iterated substitutions may lead to different results.
In fact, there are all kinds of issues with
substitutions and applying them to term-like structures. To obtain the
maximal flexibility with mimimal efforts, we defined
a \multivariate version of \HOLtm[-SUB]{CCS_Subst}
called \HOLtm[-SUB]{CCS_SUBST} based HOL's \texttt{finite\_map} theory~\cite{holdesc}.

A finite map of type \HOLty{:'a |-> 'b} is like a function of type
\HOLty{:'a -> 'b} having only finitely many elements in its
domain. In HOL, an empty finite map is denoted as \HOLtm{FEMPTY}.
If \HOLtm{fm} is a finite map, its domain (as a set of keys) is denoted as
\HOLtm{FDOM fm}. Applying \HOLtm{fm} on a certain key, say $k$, is denoted
by \HOLtm{FAPPLY fm k}.

The function \HOLtm[-SUB]{CCS_SUBST} takes a finite
map \HOLtm{fm} of type \HOLty{:'a |-> ('a, 'b) CCS} and a CCS expression,
then it returns another CCS expression in which
all occurrences of variables in the \HOLtm{fm}'s domain are substituted with
the corresponding value in \HOLtm{fm}. Such a finite map can be built from
the list of variables \HOLtm{Xs} and the corresponding targets
\HOLtm{Ps} (of the same length) by a helper function \HOLtm{fromList} (whose details are
not interesting and omitted here), while
\HOLtm[m\;,-SUB]{CCS_SUBST (fromList Xs Ps) E} is
abbreviated as \HOLtm[m\;]{CCS_SUBST (fromList Xs Ps) E}.
The substitution process is
variable-parallel thus order-independent. For most CCS operators it
just recursively call itself on subterms of current input. The only
interesting cases are at agent variables and recursion operators:
\begin{alltt}
\HOLthm[def,>>3]{Multivariate.CCS_SUBST_var}\hfill{[CCS_SUBST_var]}

\HOLthm[def,>>3]{Multivariate.CCS_SUBST_rec}\hfill{[CCS_SUBST_rec]}
\end{alltt}
Notice that, the variable substitution only happens on free
variables. In the case of $\recu X E$: if $X$ (a bound variable) is in
the domain of \HOLtm{fm}, \HOLtm[-SUB]{CCS_SUBST} must further does the
substitution on $E$ using a reduce map with $X$, so that all
occurences of agent variable $X$ in $E$ are correctly bypassed. On the
other hand, since \HOLtm[-SUB]{CCS_SUBST} only walks each subterm
once, even \HOLtm{Ps} contains free variables, these variables will
not be further substituted. Thus the process is indeed
order-independent. Below we present some key lemmas about
\HOLtm[-SUB]{CCS_SUBST} without proofs:\footnote{Hereafter,
  some new logical constants from HOL's \texttt{pred_set}
and \texttt{list} theories are used (c.f.~\cite{holdesc} for more
details.): \HOLtm{DISJOINT} denotes set disjointness;
``\HOLtm[m\;]{set Xs}'' is the set converted from the list \HOLtm{Xs};
\HOLtm{ALL_DISTINCT} says
all elements of a list are distinct with each other; \HOLtm{MAP} is
the mapping function from one list to another; \HOLtm{EVERY} means
each element of a list satisfies a predicate; \HOLtm{ZIP} creates a
new list from two lists of the same length, and each element of the new list is a pair of
elements, each from one of the old lists.}

\begin{lemma}[\texttt{CCS_SUBST_elim}]
If the free variables of $E$ is disjoint with \HOLtm{Xs}, a
substitution of \HOLtm{Xs} in $E$ does not change $E$:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_elim}
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{CCS_SUBST_self}]
Substituting each free variable $X$ in $E$ to \HOLtm[m\;]{var X} (itself)
does not change $E$:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_self}
\end{alltt}
\end{lemma}

The next lemma plays an important role. It essentially swaps the order of two substitutions:
\begin{lemma}[\texttt{CCS_SUBST_nested}]
Under certain conditions, two nested substitutions can be
converted into a single substitution where the targets are substituted first:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_nested}
\end{alltt}
\end{lemma}

The next three lemmas show the relative correctness of \texttt{CCS_SUBST}
with respect to \texttt{CCS_Subst}:
\begin{lemma}[\texttt{CCS_SUBST_sing}]
  If there is only one single variable $X$ in the map (with the target
  expression $E'$), then \HOLtm[-SUB]{CCS_SUBST} behaves exactly the
  same as (the univariate) \HOLtm[-SUB]{CCS_Subst}:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_sing}
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{CCS_SUBST_reduce}]
Under certain conditions (to get rid of substitution orders), a \multivariate substitution of variables
\HOLtm{X::Xs} can be reduced to a \multivariate substitution of
variables \HOLtm{Xs} and an \univariate substitution of $X$:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_reduce}    
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{CCS_SUBST_FOLDR}]
Under certain conditions (to get rid of substitution orders), a
\multivariate substitution can be reduced to a sequence of
of \univariate substitutions:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_FOLDR}    
\end{alltt}
\end{lemma}

Finally, the following two lemmas precisely estimate the free and
bound variables of a substituted term:
\begin{lemma}[\texttt{BV_SUBSET_BIGUNION}]
The bound variables of \HOLtm[m\;]{CCS_SUBST (fromList Xs Ps) E} have
at most the union of all bound variables from $E$ and \HOLtm{Ps}.
\begin{alltt}
\HOLthm{Multivariate.BV_SUBSET_BIGUNION}
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{FV_SUBSET_BIGUNION_PRO}]
The free variables of \HOLtm[m\;]{CCS_SUBST (fromList Xs Ps) E} have
at most the union of all free variables from $E$ and \HOLtm{Ps},
excluding \HOLtm{Xs}.
\begin{alltt}
\HOLthm{Multivariate.FV_SUBSET_BIGUNION_PRO}
\end{alltt}
\end{lemma}

It is worth noting that, in the above lemmas, the condition
\HOLtm[m\;]{DISJOINT (BV E) (set Xs)} (the bound
variables of $E$ and the free substitution variables are disjoint) is
not necessary but makes some proofs (much) easier. As these lemmas are
used in the rest work, these disjointness conditions eventually
are propagated everywhere. (We believe that they can be
all eliminated in the future.)

\subsection{\Multivariate (weakly-guarded) contexts}

Recall in Section~\ref{ss:context}, univariate contexts and their
guarded companions are defined as predicates over $\lambda$-expressions
of type $CCS\rightarrow CCS$. These predicates, such as
\HOLtm{CONTEXT}
(contexts/expressions), \HOLtm{WG} (weak-guarded contexts),
\HOLtm{SG} (strongly-guarded contexts) and \HOLtm{SEQ} (sequential
contexts), are all defined inductively, i.e.~they are built from some ``holes''
in a bottom-up way. For instance, \HOLtm[m\;]{WG (\t. prefix l t || P)}
holds because \HOLtm[m\;]{WG (\t. prefix l t)} holds on the ground,
and for any agent variable $X$, we have (by $\beta$-reduction)
\HOLtm[m\;]{(\t. prefix l t + P) (var X) = prefix l (var X) + P} (or ``$l.X + P$'' in textbook
notation) is weakly guarded (c.f.~Def.~\ref{def:guardness}).

It is possible to inductively assert multivariate contexts and their
guarded variants, but this is not easy as we need to carefully exclude the cases where
free variables occur inside any recusion operator (c.f. the footnote
at the beginning of Section~\ref{ss:SysEq}. A more elegant (and less
error-prone) solution is to define \multivariate contexts (and variants) upon the
existing \univariate definitions. This is indeed our choice.

For instance, to see the weak guardedness of $a.X + b.X + c.Y$, it is
natural to focus on each (free) variable: if we substitute each
occurrence of just one variable, say $X$, with a ``hole'' and see the
resulting term as a $\lambda$-function, then all $\lambda$-functions
derived from the original expression in this way must satisfy
\HOLtm{WG}:
\begin{alltt}
\HOLthm{Example.WG_example1}
\HOLthm{Example.WG_example2}
\end{alltt}
Notice that, \HOLtm[m\;]{prefix a t + prefix b t + prefix c (var
  Y) = CCS_Subst (prefix a (var X) + prefix b
  (var X) + prefix c  (var Y)) t X}. This above idea leads to the
following definitions of CCS contexts and weakly-guarded contexts:
\begin{alltt}
\HOLthm[def,>>3]{Multivariate.context_def}\hfill{[context_def]}

\HOLthm[def,>>3]{Multivariate.weakly_guarded_def}\hfill{[weakly_guarded_def]}
\end{alltt}
Notice that, 


\begin{alltt}
\HOLthm{Multivariate.context_combin}

\HOLthm{Multivariate.STRONG_EQUIV_subst_context}

\HOLthm{Multivariate.OBS_CONGR_subst_context}

\HOLthm{Multivariate.OBS_contracts_subst_context}
\end{alltt}

\begin{alltt}

\HOLthm{Multivariate.weakly_guarded_combin}
\end{alltt}

\subsection{\Multivariate equations and solutions}

\begin{alltt}
\HOLthm{Multivariate.CCS_equation_def}

\HOLthm{Multivariate.CCS_solution_def}
\end{alltt}

\subsection{Unique solution of equations for $\sim$ (the \multivariate version)}

\begin{alltt}
\HOLthm{Multivariate.strong_unique_solution_lemma}
  
\HOLthm{Multivariate.strong_unique_solution_thm}\hfill{[strong_unique_solution_thm]}
\end{alltt}

\subsection{Unique solution of rooted contractions (the \multivariate version)}

\begin{alltt}
\HOLthm{Multivariate.unique_solution_of_rooted_contractions}\hfill{[unique_solution_of_rooted_contractions]}
\end{alltt}
