%%%% -*- Mode: LaTeX -*-

\section{The \multivariate formalisation}
\label{sec:multivariate}

In this section,  \hl{we discuss the formalisation of the} \multivariate
cases of Milner's ``unique solution of equations (for $\sim$)''
(Theorem~\ref{t:Mil89s1}) and our ``unique solution of rooted
contractions'' (Theorem~\ref{t:rcontraBisimulationU}).
\hl{This formalisation only supports finitely many
  equations/contractions and equation variables.\footnote{The original theorems
hold for even (uncountably) infinite equations and equation variables.}}
We chose these two theorems because they both depend on the same
concept of ``weakly guarded contexts'', and Lemma~\ref{lem:milner313}.
The work is an extension of the \univariate case~\cite{EPTCS276.10}
 in the sense that neither the CCS datatype nor
the SOS rules need to be changed.

The central problem of the \multivariate formalisation is the
representation of CCS equations (expressions, contexts).
\hl{In the} \univariate formalisation, $\lambda$-functions (of type
$CCS\rightarrow CCS$) are used to represent \univariate CCS
\hl{equations, and variable substitutions are simply 
calls to $\lambda$-functions on the target CCS terms.}
This idea cannot be extended to the \multivariate case, as
we do not have a fixed number of variables to deal with.

In the  literature the variables  $X_i$ of
a system of equations $\{X_i = E_i\}_{i\in I}$ are usually considered as
\emph{equation variables}
\emph{outside} of the CCS syntax; then an equation body  $E_i$  is an \emph{open} expression
built with CCS operators plus the equation variables.
For a formal point of view, this means we either need to define a
whole new datatype (with extra equation variables) in which each CCS
opeartor must be duplicated, or we have to  add equation variables as a
new primitive (e.g.~\texttt{Var X}) to the existing CCS type (besides
the agent variables such as  \texttt{var X}).
 Then the substitution of equation
variables in $E_i\{\til P/\til X\}$ would be the \emph{syntactic substitution} of
each occurrence of $X_i$ in $E_i$ with the corresponding $P_i$.
In either cases the \emph{disjointness} between equation variables and
agent variables is syntactically
guaranteed. Both solutions are rather combersome, and require a non-trivial modification
of the formalisation of the \univariate case.

% : dealing with another CCS-like type makes the
% whole formalisation work ugly and we loose the (possibly valuable) bisimilarity concepts and
% transitional semantics of CCS expressions; on the other hand,
% modifying the CCS datatype to just support the formalisation of
% unique-solution theorems is also not acceptable.

\hl{In this project, we have followed} Milner~\cite{Mil89}, using the
same alphabet for both agent variables and equation variables.
This has allowed a large reuse of the \univariate formalisation. \hl{For instance, 
the variable
substitution function used in SOS rules [\texttt{REC}] can be also
used for substituting eqaution variables.
However, a lot of care is needed in the proofs of many
fundamental lemmas, mostly due to the variable capture issues between
equation variables and agent variables.}

% which is also the most elegant way: reusing \emph{free} agent variables
% (i.e. undefined constants) as equation variables, then the variable
% substitution function used in SOS rules [\texttt{REC}] can be also
% used for substituting eqaution variables.
% However, this approach brings us great difficulities in proving many
% fundamental lemmas, mostly due to the variable capture issues between
% equation variables and agent variables.

\subsection{Free and bound variables}

Recall the beginning of Section~\ref{s:eq},
the CCS syntax leaves the syntactic possibility that an
agent variable $A$ occurs outside the recursion operator of the same
variable. In Milner's original book chapter~\cite{milner1990operational}, the
variables which occur in Recursion (such as $X$ in $\recu X E$) are
called \emph{bound} variables, while those which occur unbound are called
\emph{free} variables. 


We denote the set of all bound variables of a
given CCS term $E$ (we recall that these are variables that are bound in a recursion
subexpression of $E$) as $\bv{E}$ (or \HOLtm[m\;]{BV E} in HOL), and the set of  free
variables as $\fv{E}$ (or \HOLtm[m\;]{FV E} in HOL). Both \HOLtm{BV} and \HOLtm{FV} have the
type ``\HOLty[of]{FV}'', i.e. functions taking CCS terms returning sets of
variables (of type \HOLty{:'a}).
% Milner didn't give their definitions explicitly. However, one can
% imagine that, for most CCS operators they just pass into
% subterms without collecting anything (and $\nil$ gives $\emptyset$).
For their definition the interesting cases are those of 
recursion and agent variables, shown below  (here \texttt{DELETE}
and \texttt{INSERT} are set-theoretic operators of HOL's
\texttt{pred_set} theory):
\begin{center}
\begin{tabular}{|l|l|}
\hline
\HOLthm[def]{CCS.FV_var} & \HOLthm[def]{CCS.FV_rec} \\
\HOLthm[def]{CCS.BV_var} & \HOLthm[def]{CCS.BV_rec} \\
\hline
\end{tabular}
\end{center}
Furthermore, $E$ is a process, written \HOLtm{IS_PROC E}, if
\hl{it does not contain any free variable}, i.e. $\fv{E} = \emptyset$:
\begin{alltt}
\HOLthm[def,>>3]{CCS.IS_PROC_def}\hfill{[IS_PROC_def]}
\end{alltt}
And a list of CCS processes can be asserted by \HOLtm{ALL_PROC} defined upon \HOLtm{IS_PROC}:
\begin{alltt}
\HOLthm[def,>>3]{CCS.ALL_PROC_def}\hfill{[ALL_PROC_def]}
\end{alltt}

Note that, in CCS expression, the set of free and bound
variables need not be disjoint, e.g.\ in  $X + \recu X E$.
More importantly, when going
from a CCS expression to its sub-expressions, the set of free
variables may increase, while the set of bound variables \hl{either
remains the same or decreases}. For instance, $\fv{\recu X (\mu.X)} = \emptyset$, while
$\fv{\mu.X} = \{X\}$. This property of $\fv{\cdot}$ brings some
difficulities when doing proofs about CCS transitions. As an evidence,
we prove the following fundamental result about $\fv{\cdot}$:

\begin{proposition}
\label{prop:transFV}
The derivatives of a process are themselves processes, i.e.
if $E \arr{\mu} E'$ and $\fv{E} = \emptyset$, then $\fv{E'} =
\emptyset$. Or, formally:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_PROC}\hfill{[TRANS_PROC]}
\end{alltt}
\end{proposition}

\begin{proof}
We  prove a stronger result,
i.e.,  the set of free variables decreases through derivatives:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_FV}\hfill{[TRANS_FV]}
\end{alltt}

\hl{Milner said it can be proved by ``an easy action
induction''}~\cite{milner1990operational}.
From HOL's viewpoint, the so-called ``action induction'' is actually a higher-order \hl{application}
of the following \emph{induction principle} generated together with SOS
rules (which essentially says \hl{that} \HOLtm{TRANS} is the smallest relation
satisfying SOS rules):
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_IND}\hfill{[TRANS_IND]}
\end{alltt}
The above long theorem has the form \HOLtm[m\;]{!P. X ==> !E u E'. TRANS E
  u E' ==> P E u E'} (with $a_0, a_1, a_2$ renamed), where the
outermost universal quantifier $P$ is a higher-order
proposition (about $E$, $\mu$ and $E'$), and $X$ is another higher-order
proposition about $P$.
What we are trying to prove is actually in the form of
\HOLtm[m\;]{!E u E'. TRANS E u E' ==> P E u E'}, where
\HOLtm[m\;]{P = \E u E'. FV E' SUBSET FV E}. Thus, if we can prove
$X$ under this specific $P$, by Modus Ponens (MP) the original proof
\hl{would have completed.}
This is the essence of action induction.
Now the original goal can be reduced to several conjunct
subgoals, each corresponding to one SOS rule. For instance, in
\hl{the subgoal for \texttt{SUM1} we need to prove}
$\fv{E_1} \subseteq \fv{E} \Longrightarrow
\fv{E_1} \subseteq \fv{E + E'}$, which holds as $\fv{E}
\subseteq \fv{E + E'} = \fv{E} \cup \fv{E'}$. Eventually we have only
the following goal left: (the term above the dash line is the goal,
those below the line are assumptions)
\begin{alltt}
        \HOLtm{FV E' SUBSET FV E DELETE X}
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
\end{alltt}
Notice that, \HOLtm[m\;]{FV E DELETE X = FV (rec X E)}, so
this is indeed the consequence of action induction on the Recursion.
Here the problem is that we know nothing about
\HOLtm[m\;]{FV ([rec X E/X] E)}. To further proceed, we need to prove
some other (easier) lemmas. First, the next lemma can be  proven
by  induction on $E$ and a few basic set-theoretic facts:
\begin{alltt}
\HOLthm[nosp]{CCS.FV_SUBSET}\hfill{[FV_SUBSET]}
\end{alltt}
Now, if we take $E' = \recu X E$ in the above lemma, we get
\HOLtm[m\;]{FV ([rec X E/X] E) SUBSET FV E UNION
  FV (rec X E)} $=$ \HOLtm[m\;]{FV E UNION (FV E DELETE X)} $=$
\HOLtm[m\;]{FV E}, i.e. the following lemma:
\begin{alltt}
\HOLthm[nosp]{CCS.FV_SUBSET_REC}\hfill{[FV_SUBSET_REC]}
\end{alltt}
Thus we can enrich the assumptions of the current proof goal with above
lemma, and obtain \HOLtm{FV E' SUBSET FV E} by the transitivity of $\subseteq$:
\begin{alltt}
        \HOLtm{FV E' SUBSET FV E DELETE X}
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
    1.  \HOLtm{FV ([rec X E/X] E) SUBSET FV E}
    2.  \HOLtm{FV E' SUBSET FV E}
\end{alltt}
Knowing \HOLtm{FV E' SUBSET FV E} we cannot prove \HOLtm{FV
  E' SUBSET FV E DELETE X}. However, if we knew \HOLtm{X
  NOTIN (FV E')}, then \HOLtm{FV E' DELETE X = FV E'}, and \hl{then}
\HOLtm{FV E' SUBSET FV E ==> FV E' DELETE X SUBSET FV E
  DELETE X}, no matter if \HOLtm{X IN FV E} or not, and the proof
\hl{would have completed.} Thus it remains to show that
\begin{alltt}
        \HOLtm{X NOTIN FV E'}
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
    1.  \HOLtm{FV ([rec X E/X] E) SUBSET FV E}
    2.  \HOLtm{FV E' SUBSET FV E}
\end{alltt}
Now we try the proof by contradiction (\emph{reductio ad absurdum}): if
the goal does not hold, i.e.
\HOLtm{X IN FV E'}, then by assumption 0 we have \HOLtm{X IN FV ([rec X
  E/X] E)}:
\begin{alltt}
        F
   ------------------------------------
    0.  \HOLtm{FV E' SUBSET FV ([rec X E/X] E)}
    1.  \HOLtm{FV ([rec X E/X] E) SUBSET FV E}
    2.  \HOLtm{FV E' SUBSET FV E}
    3.  \HOLtm{X IN FV E'}
    4.  \HOLtm{X IN FV ([rec X E/X] E)}
\end{alltt}
But this is impossible, because all free occurrences of $X$ in $E$ now become
bound in the form of $\recu X E$. In fact, the following lemma can be
proven by induction on $E$:
\begin{alltt}
\HOLthm[nosp]{CCS.NOTIN_FV_lemma}\hfill{[NOTIN_FV_lemma]}
\end{alltt}
Adding the above lemma (taking $E' = E$) into the assumption list immediately causes
a contradiction with assumption 4, and the proof finally completes.
\end{proof}

Without the above result, the proof of Milner's ``unique solution of
equations'' theorem (for $\sim$) cannot complete. Compared with the
above proof, the proof of the similar result for bound variables is easier:
\begin{proposition}
\label{prop:transBV}
if $E \arr{\mu} E'$ then $\bv{E'} \subseteq \bv{E}$, or formally:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_BV}\hfill{[TRANS_BV]}
\end{alltt}
\end{proposition}
\begin{proof}
Following the proof of Prop.~\ref{prop:transFV}, we do action
induction on $E \arr{\mu} E'$ and simplify all subgoals by set-theoretic
facts. The only subgoal left is:
\begin{alltt}
        \HOLtm{BV E' SUBSET X INSERT BV E}
   ------------------------------------
    0.  \HOLtm{BV E' SUBSET BV ([rec X E/X] E)}
\end{alltt}
Note the difference with the proof of Prop.~\ref{prop:transFV}: now
we have \texttt{INSERT} in place of \texttt{DELETE}. Then, we directly
use the assumption and the transitivity of $\subseteq$ and try to
prove the following goal instead:
\begin{alltt}
        \HOLtm{BV ([rec X E/X] E) SUBSET X INSERT BV E}
   ------------------------------------
    0.  \HOLtm{BV E' SUBSET BV ([rec X E/X] E)}
\end{alltt}
This is an easy goal, due to the following lemma which is
 proved by induction on $E$:
\begin{alltt}
\HOLthm[nosp]{CCS.BV_SUBSET}\hfill{[BV_SUBSET]}
\end{alltt}
Taking $E ' = \recu X E$ in the above lemma, we have
    \HOLtm[m\;]{BV ([rec X E/X] E) SUBSET BV E UNION BV (rec X E)},
    the right side equals to \HOLtm[m\;]{BV E UNION (X INSERT BV E)} $=$
    \HOLtm[m\;]{X INSERT BV E}. Thus
the    proof can 
 be completed.
\end{proof}

\subsection{\Multivariate substitutions}

There are two ways to represent  the \multivariate
substitution of $E\{\til P/\til X\}$ which substitutes each possibly
occurrences of free variables $X_i$ in $E$ with the corresponding
$P_i$: (1) iterately applying the existing \univariate
\HOLtm[-SUB]{CCS_Subst}; (2) defining a new \multivariate substitution
function.
% In any case, we (reasonably) assume that all $X_i$ are
%distinct with each other. 
Note that  there is the
possibility that $\til P$   syntactically  again contains variables from $\til X$, thus
different orders of iterated substitutions may lead to different results.
% In fact, there are all kinds of issues with
% substitutions and applying them to term-like structures. 
To obtain the
maximal flexibility with a reduced effort, we defined
a \multivariate version of \HOLtm[-SUB]{CCS_Subst}
called \HOLtm[-SUB]{CCS_SUBST} based HOL's \texttt{finite\_map} theory~\cite{holdesc}.

A finite map of type \HOLty{:'a |-> 'b} is like a function of type
\HOLty{:'a -> 'b} having only finitely many elements in its
domain. In HOL, an empty finite map is denoted as \HOLtm{FEMPTY}.
If \HOLtm{fm} is a finite map, its domain (as a set of keys) is denoted as
\HOLtm{FDOM fm}. Applying \HOLtm{fm} on a certain key, say $k$, is denoted
by \HOLtm{FAPPLY fm k}.

The function \HOLtm[-SUB]{CCS_SUBST} takes a finite
map \HOLtm{fm} of type \HOLty{:'a |-> ('a, 'b) CCS} and a CCS expression,
and then returns another CCS expression in which
all occurrences of variables in the \HOLtm{fm}'s domain are substituted with
the corresponding value in \HOLtm{fm}. Such a finite map can be built from
the list of variables \HOLtm{Xs} and the corresponding targets
\HOLtm{Ps} (of the same length) by a helper function \HOLtm{fromList} (whose details are
not interesting and omitted here), while
\HOLtm[m\;,-SUB]{CCS_SUBST (fromList Xs Ps) E} is
abbreviated as \HOLtm[m\;]{CCS_SUBST (fromList Xs Ps) E}.
The substitution process is
variable-parallel thus order-independent. For most CCS operators it
just recursively calls itself on subterms. The only
interesting cases are at agent variables and recursion:
\begin{alltt}
\HOLthm[def,>>3]{Multivariate.CCS_SUBST_var}\hfill{[CCS_SUBST_var]}

\HOLthm[def,>>3]{Multivariate.CCS_SUBST_rec}\hfill{[CCS_SUBST_rec]}
\end{alltt}
Note that the variable substitution only occurs on free
variables. In the case of $\recu X E$: if $X$ (a bound variable) is in
the domain of \HOLtm{fm}, \HOLtm{CCS_SUBST} must continue the
substitution on $E$ using a reduced map~--- without $X$~--- so that all
occurences of $X$ in $E$ are correctly bypassed.
\hl{Since} \HOLtm{CCS_SUBST} only runs
once on each subterm, the possible free variables in  \HOLtm{Ps} are never
 substituted. 
% Thus the process is indeed
% order-independent. 
Below we present some key lemmas about
\HOLtm{CCS_SUBST}, omitting the proofs:\footnote{Hereafter,
  some new logical constants from HOL's \texttt{pred_set}
and \texttt{list} theories are used (c.f.~\cite{holdesc} for more
details.): \HOLtm{DISJOINT} denotes set disjointness;
``\HOLtm[m\;]{set Xs}'' is the set converted from the list \HOLtm{Xs};
\HOLtm{ALL_DISTINCT} says
all elements of a list are distinct with each other; \HOLtm{MAP} is
the mapping function from one list to another; \HOLtm{EVERY} means
each element of a list satisfies a predicate; \HOLtm{ZIP} creates a
new list from two lists of the same length, and each element of the new list is a pair of
elements, each from one of the old lists.}

\begin{lemma}[\texttt{CCS_SUBST_elim}]
If the free variables of $E$ is disjoint with \HOLtm{Xs}, a
substitution of \HOLtm{Xs} in $E$ does not change $E$:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_elim}
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{CCS_SUBST_self}]
  Substituting each free variable $X$ % of \HOLtm{Xs}
  in $E$ to \HOLtm[m\;]{var X} (itself) does not change $E$:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_self}
\end{alltt}
\end{lemma}

The next lemma plays an important role. It essentially swaps the order of two substitutions:
\begin{lemma}[\texttt{CCS_SUBST_nested}]
Under certain conditions \hl{(to get rid of substitution orders)}, two nested substitutions can be
converted into a single substitution where the targets are substituted first:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_nested}
\end{alltt}
\end{lemma}

The next three lemmas show the relative correctness of \texttt{CCS\_SUBST}
w.r.t.~\texttt{CCS\_Subst}:
\begin{lemma}[\texttt{CCS_SUBST_sing}]
  If there is only one single variable $X$ in the map (with the target
  expression $E'$), then \HOLtm[-SUB]{CCS_SUBST} behaves exactly the
  same as (the \univariate) \HOLtm[-SUB]{CCS_Subst}:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_sing}
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{CCS_SUBST_reduce}]
Under certain conditions (to get rid of substitution orders), a \multivariate substitution of variables
\HOLtm{X::Xs} can be reduced to a \multivariate substitution of
variables \HOLtm{Xs} and an \univariate substitution of $X$:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_reduce}    
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{CCS_SUBST_FOLDR}]
Under certain conditions (to get rid of substitution orders), a
\multivariate substitution can be reduced to repeated applications
of \univariate substitutions of each variable:
\begin{alltt}
\HOLthm{Multivariate.CCS_SUBST_FOLDR}    
\end{alltt}
\end{lemma}

Finally, the following two lemmas precisely estimate the free and
bound variables of a substituted term:
\begin{lemma}[\texttt{BV_SUBSET_BIGUNION}]
The bound variables of \HOLtm[m\;]{CCS_SUBST (fromList Xs Ps) E} have
at most the union of all bound variables from $E$ and \HOLtm{Ps}.
\begin{alltt}
\HOLthm{Multivariate.BV_SUBSET_BIGUNION}
\end{alltt}
\end{lemma}

\begin{lemma}[\texttt{FV_SUBSET_BIGUNION_PRO}]
The free variables of \HOLtm[m\;]{CCS_SUBST (fromList Xs Ps) E} have
at most the union of all free variables from $E$ and \HOLtm{Ps},
excluding \HOLtm{Xs}.
\begin{alltt}
\HOLthm{Multivariate.FV_SUBSET_BIGUNION_PRO}
\end{alltt}
\end{lemma}

In the above lemmas, the condition
\HOLtm[m\;]{DISJOINT (BV E) (set Xs)} (the bound
variables of $E$ and the free substitution variables are disjoint) is
not necessary but makes some proofs (much) easier. 
As these lemmas are
used in the rest work, such disjointness conditions 
are propagated everywhere. 
% (We believe that they can be
% all eliminated in the future.)

\subsection{\Multivariate (weakly guarded) contexts}

Recall in Section~\ref{ss:context}, \univariate contexts and their
guarded companions are defined as predicates over $\lambda$-expressions
of type $CCS\rightarrow CCS$. These predicates, such as
\HOLtm{CONTEXT}
(contexts/expressions), \HOLtm{WG} (weak guarded contexts),
\HOLtm{SG} (guarded contexts) and \HOLtm{SEQ} (sequential
contexts), are all defined inductively, i.e.~they are built from some ``holes''
in a bottom-up way. For instance, \HOLtm[m\;]{WG (\t. prefix a t || P)}
holds because \HOLtm[m\;]{WG (\t. prefix a t)}
holds \hl{as a base case of the inductive definition of} \HOLtm{WG}:
\begin{alltt}
\HOLthm[nosp]{Congruence.WG1}\hfill{[WG1]}
\end{alltt}
\hl{For} any agent variable $X$, we have \hl{by $\beta$-reduction:}
\HOLtm[m\;]{(\t. prefix l t + P) (var X) = prefix l (var X) + P} (or ``$l.X + P$'' in textbook
notation) is weakly guarded (c.f.~Def.~\ref{def:guardness}).

It is possible to inductively assert \multivariate contexts and their
guarded variants, but care is needed as  we need to exclude the cases where
free variables occur inside a recusion operator. A more elegant
 solution is to define \multivariate contexts (and variants) upon the
existing \univariate definitions, which is the approach we have followed.
For \hl{example}, to see the weak guardedness of $a.X + b.X + c.Y$, it is
natural to focus on each (free) variable: if we substitute each
occurrence of just one variable, say $X$, with a ``hole'' and see the
resulting term as a $\lambda$-function, then all such $\lambda$-functions
must satisfy \HOLtm{WG}, i.e.~the following results hold:
\begin{alltt}
\HOLthm{Example.WG_example1}
\HOLthm{Example.WG_example2}
\end{alltt}
Also note that \HOLtm[m\;]{prefix a t + prefix b t + prefix c (var
  Y) = CCS_Subst (prefix a (var X) + prefix b
  (var X) + prefix c  (var Y)) t X}
can be expressed as a \univariate \hl{substitution of the original term.}
This idea leads to the following definitions:
\begin{alltt}
\HOLthm[def,>>3]{Multivariate.context_def}\hfill{[context_def]}

\HOLthm[def,>>3]{Multivariate.weakly_guarded_def}\hfill{[weakly_guarded_def]}
\end{alltt}
Notice that, the above definitions take an extra list of variables \HOLtm{Xs} and
assert the CCS expression \HOLtm{E} with respect to this list. This
allows us to formalise the concepts of contexts and guardedness
independently of \HOLtm{FV}. Then \HOLtm[m\;]{weakly_guarded
  (SET_TO_LIST (FV E)) E} can
be used assert that $E$ is weakly guarded w.r.t.~all its free
variables.\footnote{Here \HOLtm{SET_TO_LIST} converts a finite set
  to a list of the same elements. It turns out that, we never need this, because
  in all unique-solution theorems a list of variables \HOLtm{Xs} is fixed and
  then all equations are required to contain free variables up to
  \HOLtm{Xs}. Thus our choices in these definitions are optimal.}
(The guardedness and sequentiality can also be defined similarily
when needed, using
their \univariate companions (\texttt{SG} and \texttt{SEQ}).)

The most important property of contexts are that, strong bisimilarity
and other (pre)congruence relations are preserved by contexts, e.g.
\begin{lemma}[\texttt{STRONG_EQUIV_subst_context}]
If two tuples of processes $\til P$ and $\til Q$ are strongly
bisimilar\footnote{Hereafter, HOL terms like \HOLtm[m\;]{STRONG_EQUIV Ps Qs}
  means that, two list of CCS processes are componentwise
  (strongly) bisimilar. The same notation $\sim$ has been overloaded.}
for any context $E$ with the possible occurrences of variables $\til
X$ (same length as $\til P$ and $\til Q$), $E\{\til P/\til X\}$ and
$E\{\til Q/\til X\}$ are also strongly bisimilar:
\begin{alltt}
\HOLthm{Multivariate.STRONG_EQUIV_subst_context}
\end{alltt}
\end{lemma}
The similar properties also hold if $\sim$ is replaced with rooted
bisimilarity ($\rapprox$) or rooted contraction ($\rcontr$). (It does
not hold for weak bisimilarity $\wb$ and the contraction preorder $\mcontrBIS$.)

Another important property of contexts is their composability: if we
substitute some free variables in a context for some other contexts, the
resulting term is still a context (w.r.t.~the same set of variables):
\begin{alltt}
\HOLthm{Multivariate.context_combin}\hfill{[context_combin]}
\end{alltt}

Not every expression fit with CCS syntax is a context: any free
variable in concern must not occur inside any recusion operator
(c.f. the footnote at the beginning of Section~\ref{ss:SysEq}). In the
extreme case, if the set of free variables of an expression, say $E$,
is disjoint with a list of variables $\til X$, then this expression is
for sure a context:
\begin{alltt}
\HOLthm{Multivariate.disjoint_imp_context}\hfill{[disjoint_imp_context]}
\end{alltt}
On the other hand, for any context (w.r.t.~$\til X$) of the form $\recu Y E$, we can
conclude that, the set of free variables of $E$ excluding $Y$, is
disjoint with $\til X$, i.e.
\begin{alltt}
\HOLthm{Multivariate.context_rec}\hfill{[context_rec]}
\end{alltt}
Notice that, the above result is the best possible one. We cannot
conclude \HOLtm[m\;]{DISJOINT (FV E) (set Xs)}, because $Y$ as a bound
variable of $\recu Y E$ may be also a free variable in $\til X$. We
also cannot conclude \HOLtm[m\;]{context Xs E}, because in $\recu Y E$
it is possible that the bound variable $Y$ occurs inside another
recursion operator, then in $E$ it now becomes free. (See $\recu Y
(\recu Z (a.Y + b.Z) + c.Y)$ for such an example.)

For weakly-guarded contexts (which are also normal contexts), beside
their regular properties (i.e. weak
guardedness) as in the \univariate case (\HOLtm{WG}), we also need
their composability w.r.t.~\multivariate contexts: if we
substitute some free variables in a context $C$ for some weakly-guarded
contexts, the resulting term is weakly-guarded (w.r.t.~the same set of variables):
\begin{alltt}
\HOLthm{Multivariate.weakly_guarded_combin}\hfill{[weakly_guarded_combin]}
\end{alltt}

\subsection{\Multivariate equations and solutions}

With the formal definitions of \multivariate substitution and
\multivariate (weakly-guarded) contexts, now we are ready to formally
define \multivariate CCS equations/contractions and their (unique)
solutions. Consider a system of equation $\{X_i = E_i\}_{i\in I}$
(Def.~\ref{def:equation}), or its expanded form (here we suppose $I = [1,n]
\in \mathbb{N}$, i.e.~a finite list):
\begin{equation*}
  \begin{cases}
    &X_1 = E_1[\til X] \\
    &X_2 = E_2[\til X] \\
    & \cdots \\
    &X_n = E_n[\til X]
  \end{cases}
\end{equation*}
Consider its two essential ingredients:
\begin{itemize}
\item $\til X = (X_1, X_2, \ldots, X_n)$: a list of equation variables;
\item $\til E = (E_1, E_2, \ldots, E_n)$: a list of CCS contexts 
  with possible occurrences of free variables in $\til X$.
\end{itemize}
Obviously the two lists must have the same length. The all
distinctness of $\til X$ is not really necessary but is very
reasonable. Furthermore, we should assume $\til E$ does not contain
any other free variables not in $\til X$, as Milner's unique-solution
theorems also require the same condition.\footnote{One may think that,
  if all other (i.e.~not in $\til X$) free variables in $\til E$ have
  the same functionalities as $\nil$ as they are not to be
  substituted, then all versions of unique-solution
  theorems should still hold. However this is not the case for at
  least Milner's Theorem~\ref{t:Mil89s1} as we shall explain.}

In this project, the only optional restriction we added here is that, for each
$E_i$ the set of its bound variables must be \emph{disjoint} with $\til
X$. This restriction is actually aligned with literature based on
process constants as one should never use the same name for equation
variables and constants. However, we believe this restriction can be
removed in the future.~\footnote{Essentially, this restriction is due
  to the proof difficulties in some early lemmas about \multivariate
  substitutions where \HOLtm[m\;]{DISJOINT (BV E) (set Xs)}
  unnecessarily appears in the antecedents. Removing it requires a
  more complex proof but is indeed possible. (We have succeeded in
  fixing many such lemmas.) Once all these lemmas are
fixed, the final unique-solution theorems also do not need this
disjointness restriction.} Putting all together, below is the fomal
definition of \multivariate CCS equation:
\begin{alltt}
\HOLthm[>>3]{Multivariate.CCS_equation_def}\hfill{[CCS_equation_def]}
\end{alltt}

Now consider (formally) what is a solution $\til P$ of CCS equation. First of
all, the definition should be parametrized on a binary CCS
relation $\R$ such as $\sim$ and $\rcontr$, so that the single definition
could be used for the solution of all kind of CCS
equations/contractions. Then, of course ${\til P} \ \R\  {\til E}\{\til
P/\til X\}$ must hold, i.e.
\begin{equation*}
  \begin{cases}
    &P_1 \ \R\ E_1\{\til P/\til X\} \\
    &P_2 \ \R\ E_2\{\til P/\til X\} \\
    & \cdots \\
    &P_n \ \R\ E_n\{\til P/\til X\}
  \end{cases}
\end{equation*}
Furthermore, each $P_i$ should be pure process, i.e. having no free
variable. This is usually implicitly assumed in the literature but is
actually a \emph{must} to complete some unique-solution proofs.
At last, like the case of CCS equations, we must assume that, the
set of bound variables (i.e. process constants) must be disjoint with
$\til X$. (This disjointness requirement is optional but makes many proofs much
easier, and it can be removed in the future.) Putting all together,
below is the formal definition of a solution of \multivariate CCS
equations:\footnote{If $R$ is a binary relation of CCS processes,
  \HOLtm[m\;]{LIST_REL R} is the same binary relation but for lists of
  CCS processes. Furthermore, \HOLtm[m\;]{LIST_REL R A B} implicitly
  implies that the two lists $A$ and $B$ have the same length.}
\begin{alltt}
\HOLthm[>>3]{Multivariate.CCS_solution_def}\hfill{[CCS_solution_def]}
\end{alltt}
Notice that, in HOL, \HOLtm[m\;]{CCS_solution R Xs Es Ps <=> Ps IN
  (CCS_solution R Xs Es)}. The form in right side suggest that,
\HOLtm[m\;]{CCS_solution R Xs Es} is actually a set containing all
solutions (of \HOLtm[m\;]{CCS_equation Xs Es}). Then the unique-solution
theorems can be understood as: any two (syntactically different) elements
in the set are bisimilar.

\subsection{Unique solution of equations/contractions (the \multivariate version)}

With all above new devices (\multivariate contexts and substitutions),
the \multivariate case of Lemma~\ref{lem:milner313} is formalised
below:
\begin{alltt}
\HOLthm{Multivariate.strong_unique_solution_lemma}
\end{alltt}
Notice that, while Milner did not pointed out explicitly, the involved
weakly guarded context $E$ must contain free variables up to $\til
X$~--- the same requirement as in Theorem~\ref{t:Mil89s1}, which
otherwise does not complete. Besides, we further required that, the
bound variables of $E$ must be disjoint with $\til X$.

The \multivariate version of Theorem~\ref{t:Mil89s1} is formalised
below:
\begin{alltt}
\HOLthm{Multivariate.strong_unique_solution_thm}\hfill{[strong_unique_solution_thm]}
\end{alltt}

And the \multivariate version of Theorem~\ref{t:rcontraBisimulationU}:
\begin{alltt}
\HOLthm{Multivariate.unique_solution_of_rooted_contractions}\hfill{[unique_solution_of_rooted_contractions]}
\end{alltt}

Compared with their formal proofs in the \univariate case, although each
step related to \multivariate substitutions is more difficult than
the \univariate case, the entire proofs still follow the same outlines,
and many proof scripts can be directly copied from their \univariate version.
