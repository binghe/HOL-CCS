%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{CCS: the formal theory}
\label{ss:formalCCS}

The CCS formalisation starts with type definitions for action,
relabeling and then the  processes. We use the type ``\HOLty{:'b Label}''
for all labels (i.e. visible actions), where the type variable $\beta$ corresponds
to $\mathscr{L}$ (the set of names for labels) used at the beginning
of Section~\ref{ss:ccs}. The
cardinality and the exact elements of this type depend on the type variable $\beta$
instantiated by the end user.
All labels are divided into input and output ones.
The type ``\HOLty{:'b Label}'' is defined by HOL's \texttt{Datatype} package in the
following syntax:
\begin{lstlisting}
Datatype: Label = name 'b | coname 'b
End
\end{lstlisting}
Intuitively, with reference to the CCS terminology reported in
Section~\ref{ss:ccs}, $\beta$ represents the set of \emph{names}, and
\HOLinline{\ensuremath{\beta} \HOLTyOp{Label}} turns names into
\emph{input and output actions}.
For instance, if the type $\beta$ is instantiated to \texttt{string}
(the type of all strings), then the HOL terms \HOLtm[-In]{name "a"} and
\HOLtm[-Out]{coname "b"} denote the input action $a$ and output
action $\overline{b}$, respectively.
The type ``\HOLty{:'b Action}'' is the
union of all visible actions, plus the invisible action $\tau$
(\texttt{tau}). For instace, the input action $a$ and output
action $\overline{b}$ of type ``\HOLty{:string Action}''
are denoted by \HOLtm[-In]{label (name
  "a")} and \HOLtm[-Out]{label (coname "b")}, respectively.

The type ``\HOLty{:('a, 'b) CCS}'', accounting for the CCS
expressions, has two type variables $\alpha$ and $\beta$ corresponding%
% \footnote{The order between type variables $\alpha$ and $\beta$
%     can be arbitrary. Our choice is aligned with the literature.
% For instance, $\mathrm{CCS}(h,k)$ is the CCS subcalculus that can use at most $h$ constants
% and $k$ actions~\cite{gorrieri2017ccs}. To formalize theorems on
%  $\mathrm{CCS}(h,k)$, the required CCS type can be retrieved by instantiating the type
% variables $\alpha$ and $\beta$ in ``\HOLty{:('a, 'b) CCS}'' with types
% having the corresponding cardinalities $h$ and $k$.}
to the set of agent variables
and the set of names
respectively (indeed the CCS syntax in Section~\ref{ss:ccs} is parametric
with respect to the choice of these two sets).
%
The type ``\HOLty{:('a, 'b) CCS}'' is defined inductively by the HOL \texttt{Datatype} package
(here ``\HOLty{:'b
    Relabeling}'' is the type of all relabeling
  functions; we have also formalised relabeling, though it is not
  discussed below):
\begin{lstlisting}
Datatype: CCS = nil
              | var 'a
              | prefix ('b Action) CCS
              | sum CCS CCS
              | par CCS CCS
              | restr (('b Label) set) CCS
              | relab CCS ('b Relabeling)
              | rec 'a CCS
End
\end{lstlisting}
The above definitions allow us to use terms like \texttt{nil} and
\texttt{sum P Q} in HOL. Their correspondences with conventional CCS notations
in the literature are given in Table~\ref{tab:ccsoperator}, where
most CCS operators have also the more readable abbreviation forms,
either for end user or for \TeX{} outputs. (All
  formal theorems and definitions in this paper
  are generated from HOL4. Also, by default, all theorems are fully
  specialised, removing outermost universal quantifiers.)

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{CCS concept} & \textbf{Notation} & \textbf{HOL term} &
                                             \textbf{HOL abbrev.} & \textbf{\TeX{} outputs} \\
\hline
nil & $\textbf{0}$ & \texttt{nil} & \texttt{nil} & \HOLtm{nil} \\
prefix & $\mu.P$ & \texttt{prefix u P} & \texttt{u..P} & \HOLtm{prefix u P} \\
summation & $P + Q$ & \texttt{sum P Q} & \texttt{P + Q} & \HOLtm{sum P Q} \\
parallel composition & $P \,\mid\, Q$ & \texttt{par P Q} & \texttt{P || Q} & \HOLtm{P || Q} \\
restriction & $(\nu{}L)\;P$ & \texttt{restr L P} & \texttt{(nu L) P} & \HOLtm{restr L P}  \\
recursion & $\recu A P$ & \texttt{rec A P} & \texttt{rec A P} & \HOLtm{rec A P}  \\
relabeling & $P\;[r\!f]$ & \texttt{relab P rf} &\texttt{relab P rf} & \HOLtm{relab P rf}  \\
constant/variable & $A$ & \texttt{var A} &\texttt{var A} & \HOLtm{var A} \\
\hline
invisible action & $\tau$ & \texttt{tau} & \texttt{tau} & \HOLtm{tau} \\
input action & $a$ & \texttt{label (name a)} &\texttt{In(a)} & \HOLtm{label (name a)} \\
output action & $\outC a$ & \texttt{label (coname a)} & \texttt{Out(a)} & \HOLtm{label (coname a)} \\
\hline
variable substitution & $E\{E'/X\}$ & \texttt{CCS_Subst E E' X} &
                                           \texttt{[E'/X]  E} & \HOLtm{CCS_Subst E E' X} \\
transition & $P\overset{\mu}{\longrightarrow}Q$
                       & \texttt{TRANS P u Q} & \texttt{P ---u-> Q} & \HOLtm{TRANS P u Q} \\
weak transition & $P\overset{\mu}{\Longrightarrow}Q$
                       & \texttt{WEAK\_TRANS P u Q} & \texttt{P ==u=> Q} & \HOLtm{WEAK_TRANS P u Q} \\
$\epsilon$--transition & $P\overset{\epsilon}{\Longrightarrow}Q$
                       & \texttt{EPS P Q} & \texttt{EPS P Q} & \HOLtm{EPS P Q} \\
\hline
\end{tabular}
\end{center}
   \caption{Syntax of some CCS concepts in HOL}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes strictly follows the SOS rules given
in Fig.~\ref{f:LTSCCS}. However, they are not axioms, but the
consequence of an \emph{inductive relation} definition of
\HOLtm{TRANS} by HOL \texttt{HOL_reln} function 
(see~\citep[p.~219]{holdesc} for more details).
A successful invocation of the definitional principle returns three
important theorems (\emph{rules}, \emph{ind} and \emph{cases}):
\begin{itemize}
  \item \emph{rules} is a conjunction of implications that will be the
    same as the input term. In fact, the following formal versions of SOS rules are
    extracted from the \emph{rules} theorem:
\begin{alltt}
\HOLthm{CCS.PREFIX}\hfill\texttt{[PREFIX]}
\HOLthm{CCS.SUM1}\hfill\texttt{[SUM1]}
\HOLthm{CCS.SUM2}\hfill\texttt{[SUM2]}
\HOLthm{CCS.PAR1}\hfill\texttt{[PAR1]}
\HOLthm{CCS.PAR2}\hfill\texttt{[PAR2]}
\end{alltt}
\begin{equation*}
\HOLthm[rule,rulename=PAR3]{CCS.PAR3}
\end{equation*}
\begin{equation*}
\HOLthm[rule,rulename=RESTR]{CCS.RESTR}
\end{equation*}
\begin{equation*}
\HOLthm[rule,rulename=RELABELING]{CCS.RELABELING}
\end{equation*}
\begin{equation*}
\HOLthm[rule,rulename=REC]{CCS.REC}
\end{equation*}
\item \emph{ind} is the induction principle for the relation
  (see Section~\ref{sec:multivariate} for the exact form and its application).
\item \emph{cases} is the so-called `cases' or `inversion' theorem for
  the relations, and is used to decompose an element in the relation into the possible ways of
  obtaining it by the rules. For instance, it leads to the following
  theorem:
\begin{alltt}
\HOLthm{CCS.TRANS_SUM_EQ}\hfill{[TRANS_SUM_EQ]}
\end{alltt}
\end{itemize}

The last SOS rule \texttt{REC} (Recursion)
 says that if we substitute all occurrences of the variable $A$ in $P$ to
$(\recu A P)$ and the resulting process has a transition to $P'$
with action $u$, then $(\recu A P)$ has the same
transition. Here, ``\HOLtm[m,]{(CCS_Subst E (rec X E) X)}'' is an abbreviation
for ``\HOLtm[m,,-SUB]{(CCS_Subst E (rec X E) X)}'', where \HOLtm{CCS_Subst} is a
recursive function substituting all appearences of a free variable with another CCS term.
For most CCS operators \HOLtm{CCS_Subst} just recursively goes into a deeper
level without changing anything, e.g.
\begin{alltt}
\HOLthm{CCS.CCS_Subst_sum}\hfill{[CCS_Subst_sum]}
\end{alltt}
The only two insteresting cases are those for  agent variables and recursion:
\begin{alltt}
\HOLthm{CCS.CCS_Subst_var}\hfill{[CCS_Subst_var]}
\HOLthm{CCS.CCS_Subst_rec}\hfill{[CCS_Subst_rec]}
\end{alltt}
The variable substitutions only affects free
variables: the variable $Y$ in ``\HOLtm[m!;]{rec Y E}'' is
bound and therefore the substitution ignores it.
% The actual substitution happens in case of
% ``\HOLtm{var Y}'' if $Y$ is being
% substituted (and if \HOLtm{CCS_Subst} can actually reach it).

A useful facility exploiting the interplay
between HOL4 and Standard ML (that follows an idea of Nesi~\cite{Nesi:1992ve})
 is a recursive ML function that takes a CCS process and returns a theorem indicating all
  direct transitions of the process (if the input process is
 infinitely branching, the function will not terminate).
For instance, we know that the process $(a.\nil | \bar{a}.\nil)$ has three
possible (one-step) transitions: $(a.\nil | \bar{a}.\nil) \overset{a}{\longrightarrow}
(\nil | \bar{a}.\nil)$, $(a.\nil | \bar{a}.\nil)
\overset{\bar{a}}{\longrightarrow} (a.\nil | \nil)$ and $(a.\nil | \bar{a}.\nil)
\overset{\tau}{\longrightarrow} (\nil | \nil)$.
To completely describe all possible transitions of the process manually, the
following two facts should be proved: (1) there are indeed the three
  transitions mentioned above; (2) there is no other
  transition. For large CCS processes it is surprisingly tedious to manually derive
all the possible transitions and prove the non-existence of other transitions.
This shows the usefulness of appealing to an ML function
\texttt{CCS\_TRANS\_CONV} that is designed to automate the whole process.
For instance, taking the input $(a.\nil | \bar{a}.\nil)$ the function returns the
following theorem which describes all its one-step transitions:
\begin{alltt}
\HOLthm{Example.ex_A}
\end{alltt}

% next file: bisim.htex
