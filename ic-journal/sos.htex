%%%% -*- Mode: LaTeX -*-
%%
%% This is the draft of the 2nd part of EXPRESS/SOS 2018 paper, co-authored by
%% Prof. Davide Sangiorgi and Chun Tian.

\subsection{The CCS formalisation}
\label{ss:formalCCS}

The CCS formalisation starts with type definitions for action,
relabeling and then the  processes. We use the type ``\HOLty{:'b Label}''
for all labels (i.e. visible actions), where the type variable $\beta$ corresponds
to $\mathscr{L}$ (the set of names for labels) mentioned at the beginning
of Section~\ref{ss:ccs}. (Thus the
cardinality of ``\HOLty{:'b Label}'' depends on its type variable:
when $\beta$ is finite or countable, ``\HOLty{:'b Label}'' is countable.)
All labels are divided into input and output ones.
The type ``\HOLty{:'b Label}'' is defined by HOL's \texttt{Datatype} package in the
following syntax:
\begin{lstlisting}
Datatype: Label = name 'b | coname 'b
End
\end{lstlisting}
Intuitively, ``\HOLty{:'b Label}'' turns names in $\mathscr{L}$ into \emph{input and output labels}.
For instance, if the type $\beta$ is instantiated to \texttt{string}
(the type of all ASCII strings), then the HOL terms \HOLtm[-In]{name "a"} and
\HOLtm[-Out]{coname "b"} denote the input label $a$ and output
label $\overline{b}$, respectively.
The type ``\HOLty{:'b Action}'' is the
union of all visible actions (input and output labels) and the invisible action $\tau$
(\texttt{tau}). For instace, the input \emph{action} $a$ and output
\emph{action} $\overline{b}$ of type ``\HOLty{:string Action}''
are denoted by \HOLtm[-In]{label (name
  "a")} and \HOLtm[-Out]{label (coname "b")}, respectively. On the
other hand, \HOLtm[-In]{label (name 1)} and \HOLtm[-Out]{label (coname
  2)} could be actions of type ``\HOLty{:num Action}'', where
\HOLty{:num} is the type of natural numbers in HOL.

The type ``\HOLty{:('a, 'b) CCS}'', accounting for all CCS terms,
has two type variables $\alpha$ and $\beta$ corresponding
to the set of agent variables $\mathscr{X}$
and the set of names $\mathscr{L}$,
respectively. (Indeed the CCS syntax in Section~\ref{ss:ccs} is parametric
with respect to the choice of these two sets.)
%
The type ``\HOLty{:('a, 'b) CCS}'' is defined inductively by the
\texttt{Datatype} package
(here ``\HOLty{:'b
    Relabeling}'' is the type of all relabeling
  functions; we have also formalised relabeling, though it is not
  discussed below):
\begin{lstlisting}
Datatype: CCS = nil
              | var 'a
              | prefix ('b Action) CCS
              | sum CCS CCS
              | par CCS CCS
              | restr (('b Label) set) CCS
              | relab CCS ('b Relabeling)
              | rec 'a CCS
End
\end{lstlisting}
The above definition allows us to write terms like \texttt{nil} and
\texttt{sum P Q} in HOL4. Their correspondences with conventional CCS notations
in the literature are given in Table~\ref{tab:ccsoperator}, where
most CCS operators have also more readable abbreviated forms,
either for end users or for \TeX{} outputs. (All
  formal theorems and definitions in this paper
  are generated from HOL4. Also, by default, all theorems are fully
  specialised with outermost universal quantifiers removed.)

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{CCS concept} & \textbf{Notation} & \textbf{HOL term} &
                                             \textbf{HOL abbrev.} & \textbf{\TeX{} outputs} \\
\hline
nil & $\textbf{0}$ & \texttt{nil} & \texttt{nil} & \HOLtm{nil} \\
prefix & $\mu.P$ & \texttt{prefix u P} & \texttt{u..P} & \HOLtm{prefix u P} \\
summation & $P + Q$ & \texttt{sum P Q} & \texttt{P + Q} & \HOLtm{sum P Q} \\
parallel composition & $P \,\mid\, Q$ & \texttt{par P Q} & \texttt{P || Q} & \HOLtm{P || Q} \\
restriction & $(\nu{}L)\;P$ & \texttt{restr L P} & \texttt{(nu L) P} & \HOLtm{restr L P}  \\
recursion & $\recu A P$ & \texttt{rec A P} & \texttt{rec A P} & \HOLtm{rec A P}  \\
relabeling & $P\;[r\!f]$ & \texttt{relab P rf} &\texttt{relab P rf} & \HOLtm{relab P rf}  \\
constant/variable & $A$ & \texttt{var A} &\texttt{var A} & \HOLtm{var A} \\
\hline
invisible action & $\tau$ & \texttt{tau} & \texttt{tau} & \HOLtm{tau} \\
input action & $a$ & \texttt{label (name a)} &\texttt{In(a)} & \HOLtm{label (name a)} \\
output action & $\outC a$ & \texttt{label (coname a)} & \texttt{Out(a)} & \HOLtm{label (coname a)} \\
\hline
variable substitution & $E\{E'/X\}$ & \texttt{CCS_Subst E E' X} &
                                           \texttt{[E'/X]  E} & \HOLtm{CCS_Subst E E' X} \\
transition & $P\overset{\mu}{\longrightarrow}Q$
                       & \texttt{TRANS P u Q} & \texttt{P ---u-> Q} & \HOLtm{TRANS P u Q} \\
weak transition & $P\overset{\mu}{\Longrightarrow}Q$
                       & \texttt{WEAK\_TRANS P u Q} & \texttt{P ==u=> Q} & \HOLtm{WEAK_TRANS P u Q} \\
$\epsilon$--transition & $P\overset{\epsilon}{\Longrightarrow}Q$
                       & \texttt{EPS P Q} & \texttt{EPS P Q} & \HOLtm{EPS P Q} \\
\hline
\end{tabular}
\end{center}
   \caption{Syntax of some CCS concepts in HOL}
   \label{tab:ccsoperator}
\end{table}

The transition semantics of CCS processes strictly follows the SOS rules given
in Fig.~\ref{f:LTSCCS}. However, they are not axioms but
consequences of an \emph{inductive relation} definition of
\HOLtm{TRANS} by the \texttt{HOL_reln} function of HOL4
(see~\citep[p.~219]{holdesc} for more details).
The successful invocation of the definitional principle returns three
important theorems (\texttt{TRANS_rules}, \texttt{TRANS_ind} and \texttt{TRANS_cases}):
\begin{itemize}
  \item \texttt{TRANS_rules} is a conjunction of implications (each
    corresponding to a SOS rule) that will be the
    same as the input term. In fact, the following formal versions of SOS rules are
    extracted from \texttt{TRANS_rules}:
\begin{alltt}
\HOLthm{CCS.PREFIX}\hfill\texttt{[PREFIX]}
\HOLthm{CCS.SUM1}\hfill\texttt{[SUM1]}
\HOLthm{CCS.SUM2}\hfill\texttt{[SUM2]}
\HOLthm{CCS.PAR1}\hfill\texttt{[PAR1]}
\HOLthm{CCS.PAR2}\hfill\texttt{[PAR2]}
\end{alltt}
\begin{equation*}
\HOLthm[rule,rulename=PAR3]{CCS.PAR3}
\end{equation*}
\begin{equation*}
\HOLthm[rule,rulename=RESTR]{CCS.RESTR}
\end{equation*}
\begin{equation*}
\HOLthm[rule,rulename=RELABELING]{CCS.RELABELING}
\end{equation*}
\begin{equation*}
\HOLthm[rule,rulename=REC]{CCS.REC}
\end{equation*}
\item \texttt{TRANS_ind} is the induction principle for the relation
  (see Section~\ref{sec:multivariate} for its exact statement and an
  application in the proof of Proposition~\ref{prop:transFV}).
\item \texttt{TRANS_cases} is the so-called `cases' or `inversion' theorem for
  the relation, and is used to decompose an element in the relation into the possible ways of
  obtaining it by the rules:
\begin{alltt}
\HOLthm[nosp]{CCS.TRANS_cases}    
\end{alltt}  
For instance, the following proposition requires \texttt{TRANS_cases}:
\begin{alltt}
\HOLthm{CCS.TRANS_SUM_EQ}\hfill{[TRANS_SUM_EQ]}
\end{alltt}
\end{itemize}

In particular, the SOS rule \texttt{REC} (Recursion)
 says that if we substitute all occurrences of the variable $A$ in $P$ to
$(\recu A P)$ and the resulting process has a transition to $P'$
with an action $u$, then $(\recu A P)$ has the same
transition. Here ``\HOLtm[m,]{(CCS_Subst E (rec X E) X)}'' is an abbreviation
for ``\HOLtm[m,,-SUB]{(CCS_Subst E (rec X E) X)}'', where \HOLtm{CCS_Subst} is a
recursive function substituting all occurrences of a free variable with a CCS term.
For most CCS operators \HOLtm{CCS_Subst} just recursively goes into a deeper
level without changing anything, e.g.:
\begin{alltt}
\HOLthm{CCS.CCS_Subst_sum}\hfill{[CCS_Subst_sum]}
\end{alltt}
The only two insteresting cases are those for agent variables and recursion:
\begin{alltt}
\HOLthm{CCS.CCS_Subst_var}\hfill{[CCS_Subst_var]}
\HOLthm{CCS.CCS_Subst_rec}\hfill{[CCS_Subst_rec]}
\end{alltt}
Notice that variable substitutions only affect free
variables. For instance, the variable $Y$ in ``\HOLtm[m!;]{rec Y E}'' is
bound and therefore the substitution ignores it.

A useful facility exploiting the interplay
between HOL4 and Standard ML (which follows an idea of Nesi~\cite{Nesi:1992ve})
 is a recursive ML function that takes a CCS process and returns a theorem indicating all
  direct transitions of the process. (If the input process is
 infinitely branching, the function will not terminate, however.)
For instance, we know that the process $(a.\nil | \bar{a}.\nil)$ has three
immediate derivatives given by the following transitions:
$(a.\nil | \bar{a}.\nil) \overset{a}{\longrightarrow}
(\nil | \bar{a}.\nil)$, $(a.\nil | \bar{a}.\nil)
\overset{\bar{a}}{\longrightarrow} (a.\nil | \nil)$ and $(a.\nil | \bar{a}.\nil)
\overset{\tau}{\longrightarrow} (\nil | \nil)$.
To completely describe all possible transitions of the process, the
following two facts have to be proved: (1) there are indeed the three
  transitions mentioned above; (2) there is no other
  transition. For large CCS processes it is surprisingly tedious to manually derive
all the possible transitions and prove the non-existence of other transitions.
This shows the usefulness of appealing to an ML function
\texttt{CCS\_TRANS\_CONV} that is designed to automate the whole process.
For instance, taking the input $(a.\nil | \bar{a}.\nil)$ the function returns the
following theorem which describes all its one-step transitions:
\begin{alltt}
\HOLthm{Example.ex_A}
\end{alltt}

% next file: bisim.htex
