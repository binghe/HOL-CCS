%%%% -*- Mode: LaTeX; -*-

% 30 minutes presentation of EXPRESS/SOS 2018 paper.

% Target: 25 slides (exclude title and thanks pages)

% Table of Contents: (just write what I did in this paper!!!!!)

% 1. CCS.
% 2. Unique solution of equations (Milner)
% 3. Contraction and unique solution theorem (Sangiorgi)
% 4. Rooted contraction and unique solution theorem
% 5. Coarsest (pre)congruence contained in \approx and \mcontrBIS

% N (conclusions):
%% 1. "sometimes the greatest advantage of formalisation of theories
%% with theorem provers is the refinement of previously know results".

\begin{frame}
\frametitle{Unique Solution of Equations (Robin Milner, 1989)}
From ``Milner, R.: \emph{Communication and Concurrency}, 1989'':
\begin{theorem}[for $\sim$]
Let $\tilde{E}$ be weakly guarded with free variables at most
$\tilde{X}$, and let $\tilde{P}\sim\tilde{E}\{\tilde{P}/\tilde{X}\}$,
$\tilde{Q}\sim\tilde{E}\{\tilde{Q}/\tilde{X}\}$, then $\tilde{P}\sim\tilde{Q}$.
\end{theorem}

\begin{theorem}[for $\approx$]
Let $\tilde{E}$ be guarded and sequential with only guarded sums and
free variables as most $\tilde{X}$, and let
$\tilde{P}\approx\tilde{E}\{\tilde{P}/\tilde{X}\}$,
$\tilde{Q}\approx\tilde{E}\{\tilde{Q}/\tilde{X}\}$, then $\tilde{P}\approx\tilde{Q}$.
\end{theorem}

\begin{theorem}[for $\rapprox$]
Let $\tilde{E}$ be guarded and sequential with free variables at most
$\tilde{X}$, and let $\tilde{P}\rapprox\!\tilde{E}\{\tilde{P}/\tilde{X}\}$,
$\tilde{Q}\rapprox\!\tilde{E}\{\tilde{Q}/\tilde{X}\}$, then $\tilde{P}\rapprox\!\tilde{Q}$.
\end{theorem}
\end{frame}

\begin{frame}
\frametitle{Conditions required by Milner's theorems ($\sim$, $\rapprox$)}
\begin{definition}
$X$ is \emph{weakly guarded} in $E$ if each occurrence of $X$ is
within some subexpression $\alpha.F$ of $E$.
\end{definition}

\begin{definition}
$X$ is \emph{(strongly) guarded} in $E$ if each occurrence of $X$ is
within some subexpression $l.F$ of $E$.

$X$ is \emph{sequential} in $E$ if every subexpression of $E$ which
contains $X$, apart from $X$ itself, is of the form $\alpha.F$ or
$\Sigma \tilde{F}$.

\begin{enumerate}
\item Any $P$ (without $X$) is guarded and sequential;
\item If $E$ is sequential, then $l.E$ is guarded and sequential;
\item If $E$ is guarded and sequential, so is $\alpha.E$;
\item If $E_1$ and $E_2$ are both guarded and sequential, so is $E_1 + E_2$.
\end{enumerate}
\end{definition}
\end{frame}

\begin{frame}
\frametitle{Conditions required by Milner's theorems ($\approx$)}
\begin{definition}
$X$ is \emph{sequential with only guarded sums} in $E$ if every subexpression of $E$ which
contains $X$, apart from $X$ itself, is of the form $\alpha.F$ or
$\Sigma \alpha_i.F_i$.
\begin{enumerate}
\item Any $P$ (without $X$) is guarded and ``sequential'';
\item If $E$ is ``sequential'', then $l.E$ is guarded and
  ``sequential'';
\item If $E$ is guarded and ``sequential'', so is $\alpha.E$;
\item If $E_1$ and $E_2$ are guarded and ``sequential'', so is
  $\tau.E_1 + \tau.E_2$;
\item If $E_1$ is guarded and ``sequential'', $E_2$ is ``sequential'',
  then $\tau.E_1 + l.E_2$ is guarded and ``sequential'';
\item If $E_1$ is ``sequential'', $E_2$ is guarded and ``sequential'',
  then $l.E_1 + \tau.E_2$ is guarded and ``sequential'';
\item If $E_1$ and $E_2$ are ``sequential'', $l_1.E_1 +
  l_2.E_2$ is guarded and ``sequential''.
\end{enumerate}
\end{definition}
\end{frame}

\begin{frame}
\frametitle{A refinement of Milner's technique (D. Sangiorgi, 2017)}
\begin{definition}
A process relation ${\R}$ 
 is a \emph{(bisimulation) contraction} if whenever
 $P\RR Q$, %for all $\mu$ 
\begin{enumerate}
\item  $P \arr\mu P'$ implies there is $Q'$ such that $Q \arcap \mu
  Q'$ and $P' \RR Q'$;
\item $Q \arr\mu Q'$   implies there is $P'$ such that $P \Arcap \mu
 P'$ and $P' \wb Q'$\enspace.
\end{enumerate}
\emph{Bisimilarity contraction}, written as $P \mcontrBIS Q$, if $P\ \R\ Q$ for some contraction $\R$.
%
\end{definition}
\begin{lemma}[Precongruence of $\mcontrBIS$ in CCS]
$\mcontrBIS$ is a preorder (reflexive, transitive) and is preserved by
all CCS operators but direct sums.
\end{lemma}
\begin{theorem}[Unique Solution of Contractions]
Let $\tilde{E}$ be weakly guarded with only guarded sums and
free variables as most $\tilde{X}$, and let
$\tilde{P}\mcontrBIS\tilde{E}\{\tilde{P}/\tilde{X}\}$,
$\tilde{Q}\mcontrBIS\tilde{E}\{\tilde{Q}/\tilde{X}\}$, then $\tilde{P}\approx\tilde{Q}$.
\end{theorem}
\end{frame}

\begin{frame}
\frametitle{Further refinement of Milner's technique (C. Tian, 2018)}
\begin{definition}
Two processes $P$ and $Q$ are in \emph{rooted contraction}, written as
 $P\rcontr Q$, if
\begin{enumerate}
\item $P \arr\mu P'$ implies that there is $Q'$ with $Q \arr \mu Q'$
 and $P'\mcontrBIS Q'$;
\item $Q \arr\mu Q'$   implies that there is $P'$ with $P \Arr \mu
 P'$ and $P' \wb Q'$\enspace.
\end{enumerate}
\end{definition}
\begin{lemma}[Precongruence of $\rcontr$ in CCS]
$\mcontrBIS$ is a preorder (reflexive, transitive) and is preserved by
all CCS operators.
\end{lemma}
\begin{theorem}[Unique Solution of Rooted Contractions]
Let $\tilde{E}$ be weakly guarded with free variables as most $\tilde{X}$, and let
$\tilde{P}\rcontr\tilde{E}\{\tilde{P}/\tilde{X}\}$,
$\tilde{Q}\rcontr\tilde{E}\{\tilde{Q}/\tilde{X}\}$, then
$\tilde{P}\rapprox\tilde{Q}$ (thus also $\tilde{P}\approx\tilde{Q}$).
\end{theorem}
\end{frame}

%4
\begin{frame}[fragile]
\frametitle{Calculus of Communicating Systems (CCS)}
\end{frame}

%3
\def\HOL{\textsc{Hol}}
\newcommand\fun{{\to}}
\newcommand\prd{{\times}}
\newcommand{\ty}[1]{\textsl{#1}}
\newcommand\conj{\ \wedge\ }
\newcommand\disj{\ \vee\ }
\newcommand\imp{ \Rightarrow }
\newcommand\eqv{\ \equiv\ }
\newcommand\vbar{\mid}
\newcommand\turn{\ \vdash\ } % FIXME: "\ " resultgs in extra space
\newcommand\hilbert{\varepsilon}
\newcommand{\uquant}[1]{\forall #1.\ }
\newcommand{\equant}[1]{\exists #1.\ }
\newcommand{\hquant}[1]{\hilbert #1.\ }
\newcommand{\iquant}[1]{\exists ! #1.\ }
\newcommand{\lquant}[1]{\lambda #1.\ }
\newcommand{\ml}[1]{\mbox{{\def\_{\char'137}\texttt{#1}}}}
\newcommand{\con}[1]{\mathrm{#1}}

\newcommand\bool{\ty{bool}}
\newcommand\num{\ty{num}}
\newcommand\ind{\ty{ind}}
\newcommand\lst{\ty{list}}

\providecommand{\T}{\con{T}}
\renewcommand{\T}{\con{T}}
\newcommand\F{\con{F}}
\newcommand\OneOne{\con{One\_One}}
\newcommand\OntoSubset{\con{Onto\_Subset}}
\newcommand\Onto{\con{Onto}}
\newcommand\TyDef{\con{Type\_Definition}}

\newlength{\ttX}
\settowidth{\ttX}{\tt X}
\newcommand{\tyvar}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,0){\makebox(0,0)[b]{\footnotesize type variables}}
\put(0,1.5){\vector(0,1){4.5}}
\end{picture}}
\newcommand{\tyatom}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,2.3){\makebox(0,0)[b]{\footnotesize atomic types}}
\put(.5,3.3){\vector(0,1){2.6}}
\end{picture}}
\newcommand{\funty}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,1.5){\makebox(0,0)[b]{\footnotesize function types}}
\put(.5,0){\makebox(0,0)[b]{\footnotesize (domain, codomain)}}
\put(1,2.5){\vector(0,1){3.5}}
\end{picture}}
\newcommand{\cmpty}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(2,3.3){\makebox(0,0)[b]{\footnotesize compound types}}
\put(1.9,4.5){\vector(0,1){1.5}}
\end{picture}}

\settowidth{\ttX}{\tt X}
\newcommand{\var}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,0){\makebox(0,0)[b]{\footnotesize variables}}
\put(0,1.5){\vector(0,1){4.5}}
\end{picture}}
\newcommand{\const}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,2.3){\makebox(0,0)[b]{\footnotesize constants}}
\put(.5,3.5){\vector(0,1){2.4}}
\end{picture}}
\newcommand{\app}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(.5,1.5){\makebox(0,0)[b]{\footnotesize function applications}}
\put(.5,0){\makebox(0,0)[b]{\footnotesize (function $t$, argument $t'$)}}
\put(0.5,2.5){\vector(0,1){3.5}}
\end{picture}}
\newcommand{\abs}{\setlength{\unitlength}{\ttX}\begin{picture}(1,6)
\put(1,3.3){\makebox(0,0)[b]{\footnotesize $\lambda$-abstractions}}
\put(0.7,4.5){\vector(0,1){1.5}}
\end{picture}}

\begin{frame}[fragile]\frametitle{Higher Order Logic (HOL)}
\begin{footnotesize}
\vspace*{-1em}
\begin{columns}
\column{.73\textwidth}
\begin{definition}[Type in HOL]
\vspace*{-1.5em}
\begin{equation*}
\sigma\quad ::=\quad {\mathord{\mathop{\alpha}\limits_{\tyvar}}}
        \quad\mid\quad{\mathord{\mathop{c}\limits_{\tyatom}}}
        \quad\mid\quad\underbrace{(\sigma_1, \ldots , \sigma_n){op}}_{\cmpty}
        \quad\mid\quad\underbrace{\sigma_1\fun\sigma_2}_{\funty}
\end{equation*}
\end{definition}
\vspace*{-10pt}
\begin{definition}[Term in HOL]
\vspace*{-1em}
\begin{equation*}
t \quad ::=\quad {\mathord{\mathop{x}\limits_{\var}}}
        \quad\mid\quad{\mathord{\mathop{c}\limits_{\const}}}
        \quad\mid\quad\underbrace{t\ t'}_{\app}
        \quad\mid\quad\underbrace{\lambda x .\ t}_{\abs}
\end{equation*}
\end{definition}
\column{.23\textwidth}
\begin{block}{Primitive rules}
\begin{tiny}
\begin{enumerate}
\item Assumption introduction [{\tt ASSUME}],
\item Reflexivity [{\tt
  REFL}],
\item $\beta$-conversion [{\tt BETA\_CONV}],
\item Substitution [{\tt
SUBST}],
\item Abstraction [{\tt ABS}],
\item Type instantiation [{\tt
INST\_TYPE}], 
\item Discharging an assumption [{\tt DISCH}], 
\item Modus Ponens [{\tt MP}]
\end{enumerate}
\end{tiny}
\end{block}
\end{columns}
\begin{columns}
\column{.45\textwidth}
\vspace*{-1.2em}
\begin{block}{Logical constants}
\vspace*{-1em}
\begin{tiny}
\[
\begin{array}{l}
\turn \T       =  ((\lquant{x_{\ty{bool}}}x) =
               (\lquant{x_{\ty{bool}}}x))    \\
\turn \forall  =  \lquant{P_{\alpha\fun\ty{bool}}}\ P =
                    (\lquant{x}\T ) \\
\turn \exists  =  \lquant{P_{\alpha\fun\ty{bool}}}\
                    P({\hilbert}\ P) \\
\turn \F       =  \uquant{b_{\ty{bool}}}\ b  \\
\turn \neg    =  \lquant{b}\ b \imp \F \\
\turn {\wedge}  =  \lquant{b_1\ b_2}\uquant{b}
                     (b_1\imp (b_2 \imp b)) \imp b \\
\turn {\vee}  =  \lquant{b_1\ b_2}\uquant{b}
                   (b_1 \imp b)\imp ((b_2 \imp b) \imp b) \\
\end{array}
\]
\end{tiny}
\end{block}
\column{.5\textwidth}
\begin{block}{Axioms}
\vspace*{-1em}
\begin{tiny}
\[
\begin{array}{@{}l@{\qquad}l}
\mbox{\tiny\tt BOOL\_CASES\_AX}&\vdash \uquant{b} (b = \T ) \vee (b = \F )\\
% \\
\mbox{\tiny\tt ETA\_AX}&
\vdash \uquant{f_{\alpha\fun\beta}}(\lquant{x}f\ x) = f\\
% \\
\mbox{\tiny\tt SELECT\_AX}&
\vdash \uquant{P_{\alpha\fun\ty{bool}}\ x} P\ x \imp
P({\hilbert}\ P)\\
%  \\
\mbox{\tiny\tt INFINITY\_AX}&
\vdash \equant{f_{\ind\fun \ind}} \OneOne \ f \conj \neg(\Onto \ f)\\
\end{array}
\]
\end{tiny}
\end{block}
\end{columns}
\end{footnotesize}
\end{frame}
